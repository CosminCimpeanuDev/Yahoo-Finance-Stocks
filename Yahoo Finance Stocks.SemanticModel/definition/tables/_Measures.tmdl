table _Measures
	lineageTag: 68253867-a07a-4580-a050-238c2bf45128

	measure 'Last Close Price' = ```
			
			VAR _LastDate = CALCULATE(MAX(dimPeriod[EndDate]), ALLSELECTED(factStocks))
			
			-- Retrieve the currency for the current context
			VAR _Currency = SELECTEDVALUE(dimMeta[Currency])
			
			-- Calculate the last close price
			VAR _LastClose = CALCULATE(AVERAGE(factStocks[Close]), factStocks[Date] = _LastDate)
			
			-- Format the value with the currency symbol and custom separators
			RETURN 
			FORMAT(_LastClose, "#,0.00") & [selectedCurrencySymbol]
			```
		lineageTag: 6c3f1083-d7e4-4d91-a990-b9fdaa6f1d75

	measure BearishCandle =
			
			VAR _Diff = ABS(MAXX(factStocks, [Close]-[Open]))
			RETURN
			        IF(MAXX(factStocks, [Close]-[Open]) < 0, _Diff)
		formatString: \$#,0.###############;(\$#,0.###############);\$#,0.###############
		lineageTag: 73c3290b-f4cc-48d0-8b96-af4298e9224f

	measure BullishCandle =
			
			VAR _Diff = ABS(MAXX(factStocks, [Close]-[Open]))
			RETURN
			            IF(MAXX(factStocks, [Close]-[Open]) > 0, _Diff)
		formatString: \$#,0.###############;(\$#,0.###############);\$#,0.###############
		lineageTag: b2019628-918f-43f3-8c32-281143daab0e

	measure High = AVERAGE(factStocks[High])
		formatString: #,0.00
		lineageTag: 4bad6dbe-1892-47ab-9aaa-1431da9d9b1c

	measure Low = AVERAGE(factStocks[Low])
		formatString: \$#,0.###############;(\$#,0.###############);\$#,0.###############
		lineageTag: bd414f93-c14e-4dc1-9f26-0105dcdfbd81

	measure MaxY = ```
			MAX(factStocks[Close]) + 5 
			```
		lineageTag: a157ae4e-47a3-4b46-bbe7-72a25a6a6a59

		annotation PBI_FormatHint = {"isGeneralNumber":true}

	measure MinY = MIN(factStocks[Close]) - 5
		lineageTag: cefb0330-a88b-4274-9c67-844a34dbb656

		annotation PBI_FormatHint = {"isGeneralNumber":true}

	measure HighDistance =
			
			VAR _MaxValue = IF(MAXX(factStocks, [Close]-[Open]) > 0, MAXX(factStocks, [Close]), MAXX(factStocks, [Open]))
			VAR _High = MAXX(factStocks, [High])
			RETURN
			ABS(_High - _MaxValue) * - 1 -- I multiply by -1 to reverse the direction (Up to Down)
		lineageTag: 7a4d1a28-4784-4f16-aad2-4af4ec975130

		annotation PBI_FormatHint = {"isGeneralNumber":true}

	measure LowDistance =
			
			VAR _MinValue = IF(MAXX(factStocks, [Close]-[Open]) < 0, MAXX(factStocks, [Close]), MAXX(factStocks, [Open]))
			VAR _Low = MAXX(factStocks, [Low])
			RETURN
			ABS( _Low - _MinValue )
		formatString: \$#,0.###############;(\$#,0.###############);\$#,0.###############
		lineageTag: edfb8ed4-43ca-4fed-86f6-977af5e7ce33

	measure BeginingPeriodPrice = ```
			
			VAR _StartDate = CALCULATE(MIN(dimPeriod[StartDate]), ALLSELECTED(dimPeriod))
			VAR _Price =
			    CALCULATE(
			        MAX(factStocks[Close]),
			        factStocks[Date] = _StartDate
			    )
			VAR _NextDay =
			    CALCULATE(
			        MIN(factStocks[Date]),
			        factStocks[Date] > _StartDate
			    )
			VAR _AdjustedPrice =
			    CALCULATE(
			        MAX(factStocks[Close]),
			        factStocks[Date] = _NextDay
			    )
			RETURN
			    IF(NOT ISBLANK(_Price), _Price, _AdjustedPrice)
			
			```
		formatString: \$#,0.00;(\$#,0.00);\$#,0.00
		lineageTag: 2e534648-d856-482c-8201-aef31a6f0a6c

	measure DateFilter = IF( MAX(factStocks[Date]) >= MAX( dimPeriod[StartDate] ), 1 )
		formatString: 0
		lineageTag: 0906059c-f17d-4293-93bc-dade05489ef5

	measure 'Moving Average' = ```
			
			VAR _Period = SELECTEDVALUE(_tParameter[NbOfDays], 10)  -- Default to 7 days if no value selected
			VAR _MaxDate = LASTDATE(factStocks[Date])  -- Get the latest date in the current context
			VAR _StartDate = _MaxDate - _Period + 1  -- Calculate the start date of the moving window
			
			VAR _Numerator = CALCULATE(
			    SUM(factStocks[Close]), 
			    factStocks[Date] >= _StartDate && factStocks[Date] <= _MaxDate  -- Filter for the current period
			)
			
			VAR _Denominator = CALCULATE(
			    COUNT(factStocks[Date]), 
			    factStocks[Date] >= _StartDate && factStocks[Date] <= _MaxDate  -- Filter for the current period
			)
			
			RETURN 
			IF(_Denominator > 0, DIVIDE(_Numerator, _Denominator), BLANK())  -- Return the average or blank if no data
			
			```
		formatString: \$#,0.###############;(\$#,0.###############);\$#,0.###############
		lineageTag: c95e8a44-9c15-43eb-94b2-f0f7a5806d61

	measure 'Variation %' =
			
			VAR _Variation = DIVIDE([LastClosePrice], [BeginingPeriodPrice]) - 1
			VAR _Arrow = IF(_Variation > 0, UNICHAR(129033), UNICHAR(129035)) & " "
			RETURN
			    _Arrow & FORMAT(_Variation, "0.00%")
		lineageTag: f8bd3b3d-248d-4011-b302-df196c66e07a

	measure 'Variation Curr Vs Prec' = ```
			
			
			VAR _PrevClose  = AVERAGE( factStocks[PrevClose] )
			VAR _CurrClose = AVERAGE( factStocks[Close] )
			VAR _Variation = DIVIDE( _CurrClose , _PrevClose ) - 1
			RETURN
			 _Variation 
			```
		lineageTag: 4780cb27-9d72-4e34-9bce-1ac5ea5b16dc

		annotation PBI_FormatHint = {"isGeneralNumber":true}

	measure 'Variation Indicator' =
			
			VAR _Variation = DIVIDE([LastClosePrice], [BeginingPeriodPrice]) - 1
			RETURN
			IF( _Variation >= 0, 0, 1 )
		formatString: 0
		lineageTag: d942b59a-f2b4-4bfc-b8c0-b9124d37170c

	measure 'At Close' =
			
			VAR _MaxDate = LASTDATE(factStocks[Date])
			VAR NewLine =
			"
			"
			RETURN
			"üïíClosed at " & FORMAT( _MaxDate, "d mmmm yyyy", "en-CA")
		lineageTag: e8dd6baa-1172-41d9-9fea-332cb5c18ab7

	measure 'Green Volume' = ```
			
			VAR _PrevClose  = CALCULATE( AVERAGE(factStocks[Close]),
			                            OFFSET(-1, 
			                                    ALLSELECTED (factStocks[Date],factStocks[symbol] ),
			                                    ORDERBY(factStocks[Date] ),
			                                    PARTITIONBY(factStocks[symbol] ) 
			                                  )
			                                )
			VAR _CurrClose = AVERAGE(factStocks[Close] )
			VAR _Volume = AVERAGE(factStocks[Volume] )
			RETURN
			IF( _CurrClose > _PrevClose, _Volume)
			```
		lineageTag: baead23e-c210-443a-aeaf-e7e2baf4eb95

		annotation PBI_FormatHint = {"isGeneralNumber":true}

	measure 'Red Volume' = ```
			
			VAR _PrevClose  = CALCULATE( AVERAGE(factStocks[Close]),
			                            OFFSET(-1, 
			                                    ALLSELECTED (factStocks[Date],factStocks[symbol] ),
			                                    ORDERBY(factStocks[Date]),
			                                    PARTITIONBY(factStocks[symbol] ) 
			                                  )
			                                )
			VAR _CurrClose = AVERAGE(factStocks[Close])
			VAR _Volume = AVERAGE(factStocks[Volume])
			RETURN
			IF( _CurrClose < _PrevClose, _Volume)
			```
		lineageTag: ea9e57a8-1589-4d83-af4e-3695682a86d0

		annotation PBI_FormatHint = {"isGeneralNumber":true}

	measure MaxVolume = ```
			MAX(factStocks[Volume]) 
			```
		lineageTag: 54c00824-7db3-4d21-8068-83f42e604fa4

		annotation PBI_FormatHint = {"isGeneralNumber":true}

	measure ToolTips = ```
			
			VAR _Date = FORMAT(MAX(factStocks[Date]), "d MMMM yyyy", "en-CA")
			VAR _OpenText = "Open"
			VAR _HighText = "High"
			VAR _LowText = "Low"
			VAR _CloseText = "Close"
			VAR _VolumeText = "Volume"
			VAR _PercChangeText = "% Change"
			
			VAR _CurrencySymbol = CALCULATE(
			        SELECTEDVALUE(dimCurrencySymbol[Currency Symbol]),
			        TREATAS(VALUES(dimMeta[Currency]), dimCurrencySymbol[Currency])
			    )
			
			-- Format Open, High, Low, Close with the currency symbol on the right
			VAR _Open = FORMAT(MAX(factStocks[Open]), "0.00") & _CurrencySymbol
			VAR _High = FORMAT(MAX(factStocks[High]), "0.00") & _CurrencySymbol
			VAR _Low = FORMAT(MAX(factStocks[Low]), "0.00") & _CurrencySymbol
			VAR _Close = FORMAT(MAX(factStocks[Close]), "0.00") & _CurrencySymbol
			
			-- Format Volume and Variation as before
			VAR _Volume = FORMAT(MAX(factStocks[Volume]), "0,,.00M")
			VAR _Variation = FORMAT([Variation Curr Vs Prec], "0.00%")
			
			-- Define layout variables with reduced space
			VAR _Espace = "‚Äé " -- white space
			VAR _BeforeEspaceNumber = 11 -- Reduced space before the value
			VAR _Lenght = 6  -- Reduced length to bring values closer
			VAR _TotalLenght = _BeforeEspaceNumber + _Lenght
			
			-- Correct the calculation for the dashed line length
			VAR _LenghtOfDashLine = 
			    IF(
			        LEN(_CurrencySymbol) > 1, 
			        REPT("-", ROUND(_TotalLenght + 4, 0)),  -- Ensure the length is a valid integer
			        REPT("-", _TotalLenght + 1)
			    ) 
			
			VAR _CenteredText = ROUND(DIVIDE(_TotalLenght - LEN(_Date), 2), 0)
			
			-- Adjust for multibyte currency symbols and avoid negative values
			VAR _OpenDisplayLength = LEN(FORMAT(MAX(factStocks[Open]), "0.00")) + LEN(_CurrencySymbol)
			VAR _HighDisplayLength = LEN(FORMAT(MAX(factStocks[High]), "0.00")) + LEN(_CurrencySymbol)
			VAR _LowDisplayLength = LEN(FORMAT(MAX(factStocks[Low]), "0.00")) + LEN(_CurrencySymbol)
			VAR _CloseDisplayLength = LEN(FORMAT(MAX(factStocks[Close]), "0.00")) + LEN(_CurrencySymbol)
			VAR _VolumeDisplayLength = LEN(FORMAT(MAX(factStocks[Volume]), "0,,.00M"))
			VAR _VariationDisplayLength = LEN(FORMAT([Variation Curr Vs Prec], "0.00%"))
			
			-- Return the tooltip text with the currency symbol on the right
			RETURN
			_LenghtOfDashLine & UNICHAR(10) & REPT(_Espace, _CenteredText) & _Date & UNICHAR(10) & _LenghtOfDashLine & UNICHAR(10) &
			_OpenText & REPT(_Espace, MAX(0, _BeforeEspaceNumber - LEN(_OpenText))) & REPT(_Espace, MAX(0, _Lenght - _OpenDisplayLength)) & _Open & UNICHAR(10) &
			_HighText & REPT(_Espace, MAX(0, _BeforeEspaceNumber - LEN(_HighText))) & REPT(_Espace, MAX(0, _Lenght - _HighDisplayLength)) & _High & UNICHAR(10) &
			_LowText & REPT(_Espace, MAX(0, _BeforeEspaceNumber - LEN(_LowText))) & REPT(_Espace, MAX(0, _Lenght - _LowDisplayLength)) & _Low & UNICHAR(10) &
			_CloseText & REPT(_Espace, MAX(0, _BeforeEspaceNumber - LEN(_CloseText))) & REPT(_Espace, MAX(0, _Lenght - _CloseDisplayLength)) & _Close & UNICHAR(10) &
			_VolumeText & REPT(_Espace, MAX(0, _BeforeEspaceNumber - LEN(_VolumeText))) & REPT(_Espace, MAX(0, _Lenght - _VolumeDisplayLength)) & _Volume & UNICHAR(10) &
			_PercChangeText & REPT(_Espace, MAX(0, _BeforeEspaceNumber - LEN(_PercChangeText))) & REPT(_Espace, MAX(0, _Lenght - _VariationDisplayLength)) & _Variation
			
			```
		lineageTag: feb3128c-ad65-4435-8fea-604e1cb0c27c

	measure LastClosePrice = ```
			
			VAR _EndDate = CALCULATE(MAX(dimPeriod[EndDate]), ALLSELECTED(dimPeriod))
			VAR _LastDate =
			    MAXX(
			        FILTER(
			            factStocks,
			            factStocks[Date] <= _EndDate
			        ),
			        factStocks[Date]
			    )
			RETURN
			    IF(
			        ISBLANK(_LastDate),
			        BLANK(),  // Return BLANK if no valid _LastDate is found
			        CALCULATE(
			            MAX(factStocks[Close]),
			            factStocks[Date] = _LastDate
			        )
			    )
			
			```
		formatString: \$#,0.00;(\$#,0.00);\$#,0.00
		lineageTag: 5ed3900c-23f5-4adc-b7d2-11fe1fa620d4

		annotation PBI_FormatHint = {"currencyCulture":"en-US"}

	measure 'Variation #' = ```
			
			VAR _Delta = [LastClosePrice] - [BeginingPeriodPrice]
			VAR _Currency = 
			    CALCULATE(
			        SELECTEDVALUE(dimCurrencySymbol[Currency Symbol]),
			        TREATAS(VALUES(dimMeta[Currency]), dimCurrencySymbol[Currency])
			    )
			VAR _Period = MAX(dimPeriod[Period])
			VAR _Arrow = 
			    IF(
			        _Delta > 0,
			        UNICHAR(129033), 
			        UNICHAR(129035)
			    ) & " "
			RETURN
			    _Arrow & FORMAT(_Delta, "0.00") & _Currency & " : " & _Period
			
			```
		lineageTag: e4834ebc-bf0c-45ce-8894-a228b4c78c8b

	measure 'Exponential Moving Average' = ```
			
			VAR _Period = SELECTEDVALUE(_tParameter[NbOfDays], 10)  -- Default period of 10 if not selected
			VAR _K = 2 / (_Period + 1)  -- Smoothing factor
			VAR _MaxDate = MAX(factStocks[Date])  -- Latest date in the current context
			VAR _DatesInPeriod = DATESINPERIOD(factStocks[Date], _MaxDate, -_Period, DAY)
			
			-- Step 1: Calculate Initial EMA as SMA of the first period
			VAR _InitialEMA = 
			    CALCULATE(
			        AVERAGE(factStocks[Close]),
			        _DatesInPeriod
			    )
			
			-- Step 2: Build Weighted Sum and Total Weight
			VAR _WeightedTable =
			    ADDCOLUMNS(
			        _DatesInPeriod,
			        "Close", CALCULATE(SUM(factStocks[Close])),
			        "Weight", _K * POWER(1 - _K, DATEDIFF(factStocks[Date], _MaxDate, DAY))
			    )
			
			VAR _WeightedSum = SUMX(_WeightedTable, [Close] * [Weight])
			VAR _TotalWeight = SUMX(_WeightedTable, [Weight])
			
			-- Step 3: Calculate EMA
			VAR _EMA = DIVIDE(_WeightedSum, _TotalWeight)
			
			RETURN
			    IF(ISBLANK(_InitialEMA), BLANK(), _EMA)
			```
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: 308ea926-0875-49ed-8c66-d80d7c092ca4

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure 'Lower Band' = ```
			
			VAR _Period = SELECTEDVALUE(_tParameter[NbOfDays])
			VAR _LastDate = LASTDATE(factStocks[Date])
			VAR _DatesInPeriod = DATESINPERIOD(factStocks[Date], _LastDate, -_Period, DAY)
			VAR _SMA = '_Measures'[Moving Average]
			VAR _StdDev = 
			    STDEVX.P(
			        _DatesInPeriod,
			        CALCULATE(SUM(factStocks[Close]))
			    )
			
			RETURN
			    _SMA - (2 * _StdDev)
			
			```
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: 3c4acb54-69e9-453f-88e7-362ae243bfee

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure 'Upper Band' = ```
			
			VAR _Period = SELECTEDVALUE(_tParameter[NbOfDays])
			VAR _LastDate = LASTDATE(factStocks[Date])
			VAR _DatesInPeriod = DATESINPERIOD(factStocks[Date], _LastDate, -_Period, DAY)
			VAR _SMA = '_Measures'[Moving Average]
			VAR _StdDev = 
			    STDEVX.P(
			        _DatesInPeriod,
			        CALCULATE(SUM(factStocks[Close]))
			    )
			
			RETURN
			    _SMA + (2 * _StdDev)
			
			```
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: d2cdbe67-48d6-4277-825c-784819eae0a8

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure 'Total Close Price' = SUM(factStocks[Close])
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: 2868d987-66c9-4584-a7d7-e74abe659ba5

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure Slope =
			
			VAR Known =
			    FILTER(
			        SELECTCOLUMNS(
			            ALLSELECTED('dimCalendar'[Date]),
			            "Known[X]", 'dimCalendar'[Date],
			            "Known[Y]", [Total Close Price]
			        ),
			        AND(
			            NOT(ISBLANK(Known[X])),
			            NOT(ISBLANK(Known[Y]))
			        )
			    )
			VAR Count_Items =
			    COUNTROWS(Known)
			VAR Sum_X =
			    SUMX(Known, Known[X])
			VAR Sum_X2 =
			    SUMX(Known, Known[X] ^ 2)
			VAR Sum_Y =
			    SUMX(Known, Known[Y])
			VAR Sum_XY =
			    SUMX(Known, Known[X] * Known[Y])
			VAR Average_X =
			    AVERAGEX(Known, Known[X])
			VAR Average_Y =
			    AVERAGEX(Known, Known[Y])
			RETURN
			    DIVIDE(
			        Count_Items * Sum_XY - Sum_X * Sum_Y,
			        Count_Items * Sum_X2 - Sum_X ^ 2
			    )
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: 29b3d254-33c0-472b-8c00-9ab2da45e03a

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure 'Last Close Price Blank' = CALCULATE(LASTNONBLANKVALUE(factStocks[Date],[Total Close Price]),ALLSELECTED(factStocks[Date]))
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: e798791b-a302-41b5-ad35-cfd74ca7dfe5

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure 'First Close Price Blank' = CALCULATE(FIRSTNONBLANKVALUE(factStocks[Date],[Total Close Price]),ALLSELECTED(factStocks[Date]))
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: 71fd74e5-3a02-4ea1-902f-f5f8b8670349

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure 'Up line' = IF([Last Close Price Blank]>[First Close Price Blank], [Total Close Price], BLANK())
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: f29e95ca-041a-4f4e-9b54-1041659118d9

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure 'Down line' = IF([Last Close Price Blank]<[First Close Price Blank], [Total Close Price], BLANK())
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: 42c8d276-e9cb-4859-8dc1-23cab7eba472

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure 'SVG_Sparkline with Intersect' = ```
			
			VAR topLineColour = "blue"
			VAR bottomLineColour = "magenta"
			
			// Get the selected period's StartDate and EndDate from dimPeriod
			VAR _SelectedPeriodStart = SELECTEDVALUE(dimPeriod[StartDate])
			VAR _SelectedPeriodEnd = SELECTEDVALUE(dimPeriod[EndDate])
			
			// Calculate the X-axis range based on the selected period (dimPeriod)
			VAR XMinDate = _SelectedPeriodStart
			VAR XMaxDate = _SelectedPeriodEnd
			
			// Calculate the minimum and maximum Y values within the selected date range (factStocks[Date] within the period)
			VAR YMinValue = MINX(
			    FILTER(factStocks, factStocks[Date] >= XMinDate && factStocks[Date] <= XMaxDate),
			    CALCULATE([sumClose])
			)
			VAR YMaxValue = MAXX(
			    FILTER(factStocks, factStocks[Date] >= XMinDate && factStocks[Date] <= XMaxDate),
			    CALCULATE([sumClose])
			)
			
			// Build a table of X & Y coordinates based on the selected period, scaled to fit 50x150 viewbox
			VAR SparklineTable = ADDCOLUMNS(
			    SUMMARIZE(
			        FILTER(factStocks, factStocks[Date] >= XMinDate && factStocks[Date] <= XMaxDate),
			        factStocks[Date]
			    ),
			    "X", INT(150 * DIVIDE(factStocks[Date] - XMinDate, XMaxDate - XMinDate)),  // Scale X based on the selected period
			    "Y", INT(50 * DIVIDE([sumClose] - YMinValue, YMaxValue - YMinValue))  // Scale Y based on the selected period
			)
			
			// Concatenate X & Y coordinates into a polyline for the sparkline
			VAR Lines = CONCATENATEX(SparklineTable, [X] & "," & 50 - [Y], " ", factStocks[Date])
			
			// Calculate the intersection line position based on the selected period's data
			VAR lineIntersection = AVERAGEX(
			    FILTER(factStocks, factStocks[Date] >= XMinDate && factStocks[Date] <= XMaxDate),
			    CALCULATE([sumClose])
			)
			VAR intersectScaled = INT(50 * DIVIDE(lineIntersection - YMinValue, YMaxValue - YMinValue))
			
			// SVG Definitions for styling and markers
			VAR Defs = 
			"<defs>
			    <clipPath id='cut-bottom'>
			      <rect x='0' y='0' width='150' height='" & intersectScaled & "' />
			    </clipPath>
			
			    <marker id='circle' markerWidth='4' markerHeight='4' refX='2' refY='2' >
			      <circle cx='2' cy='2' r='1' fill='steelblue' />
			    </marker>
			
			    <marker id='circleLarge' markerWidth='4' markerHeight='4' refX='2' refY='2' >
			      <circle cx='2' cy='2' r='1.25' fill='red' stroke='black' />
			    </marker>
			
			    <marker id='arrow' markerWidth='3' markerHeight='3' refX='2' refY='2' orient='auto' >
			      <path d='M 0 0 L 10 5 L 0 10 z' fill='black' />
			    </marker>
			</defs>"
			
			// Final SVG construction
			VAR SVGImageURL = 
			    "data:image/svg+xml;utf8," & 
			    "<svg xmlns='http://www.w3.org/2000/svg' x='0px' y='0px' viewBox='-5 -5 160 60' >" & Defs &
			    "<polyline fill='none' stroke='" & bottomLineColour & "' stroke-width='3' points='" & Lines & "' stroke-linecap='round' stroke-linejoin='round' marker-start='url(#circle)' marker-mid='url(#circle)' marker-end='url(#circleLarge)' />" & 
			    "<polyline fill='none' stroke='" & topLineColour & "' stroke-width='3' points='" & Lines & "' stroke-linecap='round' stroke-linejoin='round' clip-path='url(#cut-bottom)' marker-start='url(#circle)' marker-mid='url(#circle)' marker-end='url(#circleLarge)' />" & 
			    "<line x1='0' y1='" & intersectScaled & "' x2='150' y2='" & intersectScaled & "' stroke ='grey' stroke-width ='2' stroke-dasharray='5,5' />" &
			    "</svg>"
			
			RETURN SVGImageURL
			
			```
		lineageTag: a7da3cd0-d12d-417a-abf3-e067d37b6643
		dataCategory: ImageUrl

	measure sumClose =
			
			VAR _Period = SELECTEDVALUE(_tParameter[NbOfDays])
			VAR _LastDate = LASTDATE(factStocks[Date])
			VAR _DatesInPeriod = DATESINPERIOD(factStocks[Date], _LastDate, -_Period, DAY)
			VAR _SelectedPeriodStart = SELECTEDVALUE(dimPeriod[StartDate])
			VAR _SelectedPeriodEnd = SELECTEDVALUE(dimPeriod[EndDate])
			RETURN
			    CALCULATE(
			        SUM(factStocks[Close]),
			        _DatesInPeriod,
			        FILTER(
			            factStocks,
			            factStocks[Date] >= _SelectedPeriodStart &&
			            factStocks[Date] <= _SelectedPeriodEnd
			        ),
			        ALLEXCEPT(dimLogo, dimLogo[Company])  // Ensures calculation happens per company
			    )
		formatString: 0.00
		lineageTag: 3830dde8-d634-4d36-96cf-aaea1bd2bfc6

	measure Delta = [LastClosePrice] - [BeginingPeriodPrice]
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: d35dbfa1-7998-4249-bbf7-f1e4eeee22d2

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure SVG = ```
			
			    VAR LineColourPositive = "#00A651"  // Green line for positive Delta
			    VAR LineColourNegative = "#FF0000"  // Red line for negative Delta
			    VAR PointColour = "white"            // White points on the line
			
			    // Gradient definitions for positive and negative Delta
			    VAR DefsPositive = "<defs>
			        <linearGradient id='grad' x1='0' y1='25' x2='0' y2='50' gradientUnits='userSpaceOnUse'>
			            <stop stop-color='#00A651' offset='0' />
			            <stop stop-color='#00A651' offset='0.3' />
			            <stop stop-color='white' offset='1' />
			        </linearGradient>
			    </defs>"
			    
			    VAR DefsNegative = "<defs>
			        <linearGradient id='grad' x1='0' y1='25' x2='0' y2='50' gradientUnits='userSpaceOnUse'>
			            <stop stop-color='#FF0000' offset='0' />
			            <stop stop-color='#FF0000' offset='0.3' />
			            <stop stop-color='white' offset='1' />
			        </linearGradient>
			    </defs>"
			    
			    // Date range for the sparkline (X axis) from the same dataset as the original logic
			    VAR XMinDate = SELECTEDVALUE(dimPeriod[StartDate])  // StartDate from dimPeriod table
			    VAR XMaxDate = SELECTEDVALUE(dimPeriod[EndDate])    // EndDate from dimPeriod table
			    
			    // Calculate overall min and max stock closing values for the selected date range
			    VAR YMinValue = MINX(
			        FILTER(factStocks, factStocks[Date] >= XMinDate && factStocks[Date] <= XMaxDate),
			        CALCULATE([sumClose])
			    )
			    VAR YMaxValue = MAXX(
			        FILTER(factStocks, factStocks[Date] >= XMinDate && factStocks[Date] <= XMaxDate),
			        CALCULATE([sumClose])
			    )
			    
			    // Build table of X & Y coordinates based on the same date range, scaled to the 50 x 150 viewbox
			    VAR SparklineTable = ADDCOLUMNS(
			        SUMMARIZE(
			            FILTER(factStocks, factStocks[Date] >= XMinDate && factStocks[Date] <= XMaxDate),
			            factStocks[Date]
			        ),
			        "X", INT(150 * DIVIDE(factStocks[Date] - XMinDate, XMaxDate - XMinDate)),
			        "Y", INT(50 * DIVIDE([sumClose] - YMinValue, YMaxValue - YMinValue))
			    )
			    
			    // Concatenate X & Y coordinates to form the sparkline line path
			    VAR Lines = CONCATENATEX(SparklineTable, [X] & "," & 50 - [Y], " ", factStocks[Date])
			    
			    // Last data points for highlighting the final point on the sparkline
			    VAR LastSparkYValue = MAXX(FILTER(SparklineTable, factStocks[Date] = XMaxDate), [Y])
			    VAR LastSparkXValue = MAXX(FILTER(SparklineTable, factStocks[Date] = XMaxDate), [X])
			    
			    // Determine whether the Delta is positive or negative and use the corresponding gradient and line color
			    VAR Gradient = IF([Delta] > 0, DefsPositive, DefsNegative)
			    VAR LineColour = IF([Delta] > 0, LineColourPositive, LineColourNegative)
			    
			    // Scale the Moving Average value to fit the 50 x 150 viewbox
			    VAR ReferenceLineScaled = INT(50 * DIVIDE([Moving Average] - YMinValue, YMaxValue - YMinValue))
			    
			    // Build the SVG image
			    VAR SVGImageURL = 
			        "data:image/svg+xml;utf8," & 
			        "<svg xmlns='http://www.w3.org/2000/svg' x='0px' y='0px' viewBox='-7 -7 164 64'>" & 
			        Gradient &  // Use the correct gradient definition (green or red)
			        // Opaque area filled with gradient
			        "<polyline fill='url(#grad)' fill-opacity='0.3' stroke='transparent' stroke-width='0' points='0,50 " & Lines & " 150,50 Z' />" & 
			        // Line with the defined color and stroke width
			        "<polyline fill='transparent' stroke='" & LineColour & "' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' points='" & Lines & "' />" & 
			        // Last point with the circle to highlight it
			        "<circle cx='" & LastSparkXValue & "' cy='" & 50 - LastSparkYValue & "' r='4' stroke='" & LineColour & "' stroke-width='3' fill='" & PointColour & "' />" & 
			        // Add the reference line (moving average line) at the calculated position
			        "<line x1='0' y1='" & ReferenceLineScaled & "' x2='150' y2='" & ReferenceLineScaled & "' stroke='grey' stroke-width='2' stroke-dasharray='5,5' />" & 
			        "</svg>"
			    
			    RETURN 
			        SVGImageURL
			
			```
		lineageTag: 018f5a74-c661-4f24-b27e-9ae0e2f700fe
		dataCategory: ImageUrl

	measure companyNameAndTags =
			
			VAR _Company = MAX(dimLogo[Company])
			VAR _Symbol = MAX(dimMeta[Symbol])
			VAR _Industry = MAX(dimMeta[Industry])
			VAR _Sector = MAX(dimMeta[Sector])
			VAR NewLine =
			"
			"
			RETURN
			_Company & NewLine & "üè∑Ô∏è:" & _Sector
		lineageTag: 71d51399-5cd6-425e-b078-646b04cc2c7a

	measure SVGLineAreaChartTabel = ```
			
			    VAR LineColourPositive = "#00A651"  // Green line for positive Delta
			    VAR LineColourNegative = "#FF0000"  // Red line for negative Delta
			    VAR PointColour = "white"           // White points on the line
			
			    // Gradient definitions for positive and negative Delta
			    VAR DefsPositive = "<defs>
			        <linearGradient id='grad' x1='0' y1='22.5' x2='0' y2='45' gradientUnits='userSpaceOnUse'>
			            <stop stop-color='#00A651' offset='0' />
			            <stop stop-color='#00A651' offset='0.3' />
			            <stop stop-color='white' offset='1' />
			        </linearGradient>
			    </defs>"
			
			    VAR DefsNegative = "<defs>
			        <linearGradient id='grad' x1='0' y1='22.5' x2='0' y2='45' gradientUnits='userSpaceOnUse'>
			            <stop stop-color='#FF0000' offset='0' />
			            <stop stop-color='#FF0000' offset='0.3' />
			            <stop stop-color='white' offset='1' />
			        </linearGradient>
			    </defs>"
			
			    // Date range for the sparkline (X axis) 
			    VAR XMinDate = 
			        IF (
			            ISBLANK(SELECTEDVALUE(dimPeriod[StartDate])), 
			            MIN(factStocks[Date]), 
			            SELECTEDVALUE(dimPeriod[StartDate]) 
			        ) 
			    VAR XMaxDate = CALCULATE(
			        MAX(factStocks[Date]), 
			        factStocks[Date] <= SELECTEDVALUE(dimPeriod[EndDate])
			    )
			
			    // Calculate overall min and max stock closing values for the selected date range
			    VAR YMinValue = MINX(
			        FILTER(factStocks, factStocks[Date] >= XMinDate && factStocks[Date] <= XMaxDate),
			        CALCULATE([sumClose])
			    )
			    VAR YMaxValue = MAXX(
			        FILTER(factStocks, factStocks[Date] >= XMinDate && factStocks[Date] <= XMaxDate),
			        CALCULATE([sumClose])
			    )
			
			    // Build table of X & Y coordinates based on the same date range, scaled to the 60x30 viewbox
			    VAR SparklineTable = ADDCOLUMNS(
			        SUMMARIZE(
			            FILTER(factStocks, factStocks[Date] >= XMinDate && factStocks[Date] <= XMaxDate),
			            factStocks[Date]
			        ),
			        "X", 
			            // Ensure X values start from 0 and adjust for potential rounding errors
			            ROUND(60 * DIVIDE(DATEDIFF(XMinDate, factStocks[Date], DAY), DATEDIFF(XMinDate, XMaxDate, DAY)), 2), 
			        "Y", INT(30 * DIVIDE([sumClose] - YMinValue, YMaxValue - YMinValue))
			    )
			
			    // Concatenate X & Y coordinates to form the sparkline line path
			    VAR Lines = CONCATENATEX(SparklineTable, [X] & "," & 30 - [Y], " ", factStocks[Date])
			
			    // Last data points for highlighting the final point on the sparkline
			    VAR LastSparkYValue = MAXX(FILTER(SparklineTable, factStocks[Date] = XMaxDate), [Y])
			    VAR LastSparkXValue = MAXX(FILTER(SparklineTable, factStocks[Date] = XMaxDate), [X])
			
			    // Determine whether the Delta is positive or negative and use the corresponding gradient and line color
			    VAR Gradient = IF([Delta] > 0, DefsPositive, DefsNegative)
			    VAR LineColour = IF([Delta] > 0, LineColourPositive, LineColourNegative)
			
			    // Scale the Moving Average value to fit the 30x60 viewbox
			    VAR ReferenceLineScaled = INT(30 * DIVIDE([Moving Average] - YMinValue, YMaxValue - YMinValue))
			
			    // Build the SVG image
			    VAR SVGImageURL = 
			        "data:image/svg+xml;utf8," & 
			        "<svg xmlns='http://www.w3.org/2000/svg' x='0px' y='0px' viewBox='-4 -4 67 37'>" & 
			        Gradient &  // Use the correct gradient definition (green or red)
			        // Opaque area filled with gradient
			        "<polyline fill='url(#grad)' fill-opacity='0.3' stroke='transparent' stroke-width='0' points='0,30 " & Lines & " 60,30 Z' />" & 
			        // Line with the defined color and stroke width
			        "<polyline fill='transparent' stroke='" & LineColour & "' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' points='" & Lines & "' />" & 
			        // Last point with the circle to highlight it
			        "<circle cx='" & LastSparkXValue & "' cy='" & 30 - LastSparkYValue & "' r='2.5' stroke='" & LineColour & "' stroke-width='2' fill='" & PointColour & "' />" & 
			        // Add the reference line (moving average line) at the calculated position
			        "<line x1='0' y1='" & ReferenceLineScaled & "' x2='60' y2='" & ReferenceLineScaled & "' stroke='grey' stroke-width='1.5' stroke-dasharray='4,4' />" & 
			        "</svg>"
			
			    RETURN 
			        SVGImageURL
			```
		lineageTag: 59e0d4b2-d73d-40ee-845d-7ad62474ab3c
		dataCategory: ImageUrl

	measure sumClose_Dynamic = [sumClose]
		lineageTag: 919216b5-7bd9-498c-85ba-b8fda88cf385

		formatStringDefinition = ```
				VAR SelectedCurrency = 
				    CALCULATE(
				        SELECTEDVALUE(dimCurrencySymbol[Currency Symbol]),
				        TREATAS(VALUES(dimMeta[Currency]), dimCurrencySymbol[Currency])
				    )
				RETURN
				    "#,0.0#" & " " & SelectedCurrency
				```

	measure selectedCurrencySymbol = ```
			
			    CALCULATE(
			        SELECTEDVALUE(dimCurrencySymbol[Currency Symbol]),
			        TREATAS(VALUES(dimMeta[Currency]), dimCurrencySymbol[Currency])
			    )
			```
		lineageTag: 4af61efb-a953-4ec9-861c-e215cf92e235

	measure sumClose_Dynamic_Symbol = ```
			
			VAR NewLine = 
			"
			"
			VAR _Variation = DIVIDE([LastClosePrice], [BeginingPeriodPrice]) - 1
			VAR VariationText = 
			    IF(
			        _Variation > 0,
			        FORMAT([Variation %], "#,0.0#") & " " & UNICHAR(128994),  -- Green Dot
			        FORMAT([Variation %], "#,0.0#") & " " & UNICHAR(128308)  -- Red Dot
			    )
			RETURN
			FORMAT([_0_sumClose], "#,0.0#") & " " & [selectedCurrencySymbol] & NewLine & VariationText
			
			```
		lineageTag: 4d7d6e7a-320c-4530-81be-d2f81f390ffd

	measure companyNameAndTags_v2 =
			
			VAR _Company = MAX(dimLogo[Company])
			VAR _Symbol = MAX(dimMeta[Symbol])
			VAR _Industry = MAX(dimMeta[Industry])
			VAR _Sector = MAX(dimMeta[Sector])
			VAR _CurrencyName = MAX(dimMeta[Currency])
			VAR _exchangeName = MAX(dimMeta[Exchange Name])
			VAR NewLine =
			"
			"
			RETURN
			"üè∑Ô∏è:" & _Symbol & " | ü™ô:" & _CurrencyName & " | üí∞:" & _exchangeName
		lineageTag: 07a13af8-3334-4044-867d-59f8ea5c34ed

	measure _0_sumClose = ```
			
			VAR _LastDate = LASTDATE(factStocks[Date])
			RETURN
			    CALCULATE(
			        AVERAGE(factStocks[Close]),
			        factStocks[Date] = _LastDate
			          // Ensures calculation happens per company
			    )
			
			```
		lineageTag: 2691be47-fb96-49f9-ab1c-3b5a31ea0bbb

		annotation PBI_FormatHint = {"isGeneralNumber":true}

	column _Blank
		formatString: 0
		lineageTag: a889a677-a184-452c-9ab3-1dbdcb601569
		summarizeBy: sum
		isNameInferred
		sourceColumn: [_Blank]

		annotation SummarizationSetBy = Automatic

	partition _Measures = calculated
		mode: import
		source = Row("_Blank", BLANK())

	annotation PBI_Id = d3fe511137dc4693a1ba9c24c6d6306b

	annotation 436ba87b-9c83-4389-a31b-ebd06a36be98 = {"Expression":""}

