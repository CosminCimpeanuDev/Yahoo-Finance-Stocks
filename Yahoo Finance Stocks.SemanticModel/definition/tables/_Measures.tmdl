table _Measures
	lineageTag: 68253867-a07a-4580-a050-238c2bf45128

	measure 'Last Close Price' = ```
			
			VAR _LastDate = CALCULATE(MAX(dimPeriod[EndDate]), ALLSELECTED(factStocks))
			
			-- Retrieve the currency for the current context
			VAR _Currency = SELECTEDVALUE(dimMeta[Currency])
			
			-- Map the currency code to its symbol
			VAR _CurrencySymbol = 
			    SWITCH(
			        _Currency,
			        "USD", "$",
			        "EUR", "â‚¬",
			        "GBP", "Â£",
			        "JPY", "Â¥",
			        _Currency -- Fallback to the currency code
			    )
			
			-- Calculate the last close price
			VAR _LastClose = CALCULATE(AVERAGE(factStocks[Close]), factStocks[Date] = _LastDate)
			
			-- Format the value with the currency symbol and custom separators
			RETURN 
			FORMAT(_LastClose, "#,0.00", "de-DE") & _CurrencySymbol
			```
		lineageTag: 6c3f1083-d7e4-4d91-a990-b9fdaa6f1d75

	measure BearishCandle =
			
			VAR _Diff = ABS(MAXX(factStocks, [Close]-[Open]))
			RETURN
			        IF(MAXX(factStocks, [Close]-[Open]) < 0, _Diff)
		formatString: \$#,0.###############;(\$#,0.###############);\$#,0.###############
		lineageTag: 73c3290b-f4cc-48d0-8b96-af4298e9224f

	measure BullishCandle =
			
			VAR _Diff = ABS(MAXX(factStocks, [Close]-[Open]))
			RETURN
			            IF(MAXX(factStocks, [Close]-[Open]) > 0, _Diff)
		formatString: \$#,0.###############;(\$#,0.###############);\$#,0.###############
		lineageTag: b2019628-918f-43f3-8c32-281143daab0e

	measure High = AVERAGE(factStocks[High])
		formatString: #,0.00
		lineageTag: 4bad6dbe-1892-47ab-9aaa-1431da9d9b1c

	measure Low = AVERAGE(factStocks[Low])
		formatString: \$#,0.###############;(\$#,0.###############);\$#,0.###############
		lineageTag: bd414f93-c14e-4dc1-9f26-0105dcdfbd81

	measure MaxY = ```
			MAX(factStocks[Close]) + 5 
			```
		lineageTag: a157ae4e-47a3-4b46-bbe7-72a25a6a6a59

		annotation PBI_FormatHint = {"isGeneralNumber":true}

	measure MinY = MIN(factStocks[Close]) - 5
		lineageTag: cefb0330-a88b-4274-9c67-844a34dbb656

		annotation PBI_FormatHint = {"isGeneralNumber":true}

	measure HighDistance =
			
			VAR _MaxValue = IF(MAXX(factStocks, [Close]-[Open]) > 0, MAXX(factStocks, [Close]), MAXX(factStocks, [Open]))
			VAR _High = MAXX(factStocks, [High])
			RETURN
			ABS(_High - _MaxValue) * - 1 -- I multiply by -1 to reverse the direction (Up to Down)
		lineageTag: 7a4d1a28-4784-4f16-aad2-4af4ec975130

		annotation PBI_FormatHint = {"isGeneralNumber":true}

	measure LowDistance =
			
			VAR _MinValue = IF(MAXX(factStocks, [Close]-[Open]) < 0, MAXX(factStocks, [Close]), MAXX(factStocks, [Open]))
			VAR _Low = MAXX(factStocks, [Low])
			RETURN
			ABS( _Low - _MinValue )
		formatString: \$#,0.###############;(\$#,0.###############);\$#,0.###############
		lineageTag: edfb8ed4-43ca-4fed-86f6-977af5e7ce33

	measure BeginingPeriodPrice = ```
			
			VAR _StartDate = CALCULATE(MAX(dimPeriod[StartDate]), ALLSELECTED(factStocks))
			VAR _Price = 
			    CALCULATE(
			        MAX(factStocks[Close]), 
			        factStocks[Date] = _StartDate
			    )
			VAR _AdjustedPrice = 
			    CALCULATE(
			        MAX(factStocks[Close]), 
			        factStocks[Date] = _StartDate + 3
			    )
			RETURN
			    IF(_Price = BLANK(), _AdjustedPrice, _Price)
			
			```
		formatString: \$#,0.00;(\$#,0.00);\$#,0.00
		lineageTag: 2e534648-d856-482c-8201-aef31a6f0a6c

	measure DateFilter = IF( MAX(factStocks[Date]) >= MAX( dimPeriod[StartDate] ), 1 )
		formatString: 0
		lineageTag: 0906059c-f17d-4293-93bc-dade05489ef5

	measure 'Moving Average' = ```
			
			VAR _Period = SELECTEDVALUE(_tParameter[NbOfDays], 10)  -- Default to 7 days if no value selected
			VAR _MaxDate = LASTDATE(factStocks[Date])  -- Get the latest date in the current context
			VAR _StartDate = _MaxDate - _Period + 1  -- Calculate the start date of the moving window
			
			VAR _Numerator = CALCULATE(
			    SUM(factStocks[Close]), 
			    factStocks[Date] >= _StartDate && factStocks[Date] <= _MaxDate  -- Filter for the current period
			)
			
			VAR _Denominator = CALCULATE(
			    COUNT(factStocks[Date]), 
			    factStocks[Date] >= _StartDate && factStocks[Date] <= _MaxDate  -- Filter for the current period
			)
			
			RETURN 
			IF(_Denominator > 0, DIVIDE(_Numerator, _Denominator), BLANK())  -- Return the average or blank if no data
			
			```
		formatString: \$#,0.###############;(\$#,0.###############);\$#,0.###############
		lineageTag: c95e8a44-9c15-43eb-94b2-f0f7a5806d61

	measure 'Variation %' =
			
			VAR _Variation = DIVIDE([Last Close Price Number], [BeginingPeriodPrice]) - 1
			VAR _Arrow = IF(_Variation > 0, UNICHAR(129033), UNICHAR(129035)) & " "
			RETURN
			    _Arrow & FORMAT(_Variation, "0.00%")
		lineageTag: f8bd3b3d-248d-4011-b302-df196c66e07a

	measure 'Variation Curr Vs Prec' = ```
			
			
			VAR _PrevClose  = AVERAGE( factStocks[PrevClose] )
			VAR _CurrClose = AVERAGE( factStocks[Close] )
			VAR _Variation = DIVIDE( _CurrClose , _PrevClose ) - 1
			RETURN
			 _Variation 
			```
		lineageTag: 4780cb27-9d72-4e34-9bce-1ac5ea5b16dc

		annotation PBI_FormatHint = {"isGeneralNumber":true}

	measure 'Variation Indicator' =
			
			VAR _Variation = DIVIDE([Last Close Price Number], [BeginingPeriodPrice]) - 1
			RETURN
			IF( _Variation >= 0, 0, 1 )
		formatString: 0
		lineageTag: d942b59a-f2b4-4bfc-b8c0-b9124d37170c

	measure 'At Close' =
			
			VAR _MaxDate = LASTDATE(factStocks[Date])
			VAR _MarketRef = " Â· USD Â· NASDAQ"
			VAR NewLine =
			"
			"
			RETURN
			"At close: " & FORMAT( _MaxDate, "d mmmm yyyy", "en-CA") & _MarketRef & "ðŸ‘Œ" & NewLine & "ðŸ˜Ž" & "TESTTTTTTTTTTTTTT"
		lineageTag: e8dd6baa-1172-41d9-9fea-332cb5c18ab7

	measure CompanyName = MAX(dimMeta[Company Name])
		lineageTag: c5791ee4-ebe3-4e7f-bfa4-2334e88ef379

	measure 'Green Volume' = ```
			
			VAR _PrevClose  = CALCULATE( AVERAGE(factStocks[Close]),
			                            OFFSET(-1, 
			                                    ALLSELECTED (factStocks[Date],factStocks[symbol] ),
			                                    ORDERBY(factStocks[Date] ),
			                                    PARTITIONBY(factStocks[symbol] ) 
			                                  )
			                                )
			VAR _CurrClose = AVERAGE(factStocks[Close] )
			VAR _Volume = AVERAGE(factStocks[Volume] )
			RETURN
			IF( _CurrClose > _PrevClose, _Volume)
			```
		lineageTag: baead23e-c210-443a-aeaf-e7e2baf4eb95

		annotation PBI_FormatHint = {"isGeneralNumber":true}

	measure 'Red Volume' = ```
			
			VAR _PrevClose  = CALCULATE( AVERAGE(factStocks[Close]),
			                            OFFSET(-1, 
			                                    ALLSELECTED (factStocks[Date],factStocks[symbol] ),
			                                    ORDERBY(factStocks[Date]),
			                                    PARTITIONBY(factStocks[symbol] ) 
			                                  )
			                                )
			VAR _CurrClose = AVERAGE(factStocks[Close])
			VAR _Volume = AVERAGE(factStocks[Volume])
			RETURN
			IF( _CurrClose < _PrevClose, _Volume)
			```
		lineageTag: ea9e57a8-1589-4d83-af4e-3695682a86d0

		annotation PBI_FormatHint = {"isGeneralNumber":true}

	measure MaxVolume = ```
			MAX(factStocks[Volume]) 
			```
		lineageTag: 54c00824-7db3-4d21-8068-83f42e604fa4

		annotation PBI_FormatHint = {"isGeneralNumber":true}

	measure ToolTips = ```
			
			VAR _Date = FORMAT(MAX(factStocks[Date]), "d MMMM yyyy", "en-CA")
			VAR _OpenText = "Open"
			VAR _HighText = "High"
			VAR _LowText = "Low"
			VAR _CloseText = "Close"
			VAR _VolumeText = "Volume"
			VAR _PercChangeText = "% Change"
			
			VAR _CurrencySymbol = CALCULATE(
			        SELECTEDVALUE(dimCurrencySymbol[Currency Symbol]),
			        TREATAS(VALUES(dimMeta[Currency]), dimCurrencySymbol[Currency])
			    )
			
			-- Format Open, High, Low, Close with the currency symbol on the right
			VAR _Open = FORMAT(MAX(factStocks[Open]), "0.00") & _CurrencySymbol
			VAR _High = FORMAT(MAX(factStocks[High]), "0.00") & _CurrencySymbol
			VAR _Low = FORMAT(MAX(factStocks[Low]), "0.00") & _CurrencySymbol
			VAR _Close = FORMAT(MAX(factStocks[Close]), "0.00") & _CurrencySymbol
			
			-- Format Volume and Variation as before
			VAR _Volume = FORMAT(MAX(factStocks[Volume]), "0,,.00M")
			VAR _Variation = FORMAT([Variation Curr Vs Prec], "0.00%")
			
			-- Define layout variables with reduced space
			VAR _Espace = "â€Ž " -- white space
			VAR _BeforeEspaceNumber = 11 -- Reduced space before the value
			VAR _Lenght = 6  -- Reduced length to bring values closer
			VAR _TotalLenght = _BeforeEspaceNumber + _Lenght
			
			-- Correct the calculation for the dashed line length
			VAR _LenghtOfDashLine = 
			    IF(
			        LEN(_CurrencySymbol) > 1, 
			        REPT("-", ROUND(_TotalLenght + 4, 0)),  -- Ensure the length is a valid integer
			        REPT("-", _TotalLenght + 1)
			    ) 
			
			VAR _CenteredText = ROUND(DIVIDE(_TotalLenght - LEN(_Date), 2), 0)
			
			-- Adjust for multibyte currency symbols and avoid negative values
			VAR _OpenDisplayLength = LEN(FORMAT(MAX(factStocks[Open]), "0.00")) + LEN(_CurrencySymbol)
			VAR _HighDisplayLength = LEN(FORMAT(MAX(factStocks[High]), "0.00")) + LEN(_CurrencySymbol)
			VAR _LowDisplayLength = LEN(FORMAT(MAX(factStocks[Low]), "0.00")) + LEN(_CurrencySymbol)
			VAR _CloseDisplayLength = LEN(FORMAT(MAX(factStocks[Close]), "0.00")) + LEN(_CurrencySymbol)
			VAR _VolumeDisplayLength = LEN(FORMAT(MAX(factStocks[Volume]), "0,,.00M"))
			VAR _VariationDisplayLength = LEN(FORMAT([Variation Curr Vs Prec], "0.00%"))
			
			-- Return the tooltip text with the currency symbol on the right
			RETURN
			_LenghtOfDashLine & UNICHAR(10) & REPT(_Espace, _CenteredText) & _Date & UNICHAR(10) & _LenghtOfDashLine & UNICHAR(10) &
			_OpenText & REPT(_Espace, MAX(0, _BeforeEspaceNumber - LEN(_OpenText))) & REPT(_Espace, MAX(0, _Lenght - _OpenDisplayLength)) & _Open & UNICHAR(10) &
			_HighText & REPT(_Espace, MAX(0, _BeforeEspaceNumber - LEN(_HighText))) & REPT(_Espace, MAX(0, _Lenght - _HighDisplayLength)) & _High & UNICHAR(10) &
			_LowText & REPT(_Espace, MAX(0, _BeforeEspaceNumber - LEN(_LowText))) & REPT(_Espace, MAX(0, _Lenght - _LowDisplayLength)) & _Low & UNICHAR(10) &
			_CloseText & REPT(_Espace, MAX(0, _BeforeEspaceNumber - LEN(_CloseText))) & REPT(_Espace, MAX(0, _Lenght - _CloseDisplayLength)) & _Close & UNICHAR(10) &
			_VolumeText & REPT(_Espace, MAX(0, _BeforeEspaceNumber - LEN(_VolumeText))) & REPT(_Espace, MAX(0, _Lenght - _VolumeDisplayLength)) & _Volume & UNICHAR(10) &
			_PercChangeText & REPT(_Espace, MAX(0, _BeforeEspaceNumber - LEN(_PercChangeText))) & REPT(_Espace, MAX(0, _Lenght - _VariationDisplayLength)) & _Variation
			
			```
		lineageTag: feb3128c-ad65-4435-8fea-604e1cb0c27c

	measure 'Last Close Price Number' = CALCULATE(LASTNONBLANKVALUE(factStocks[Date],[Total Close Price]),ALLSELECTED(factStocks[Date]))
		formatString: \$#,0.00;(\$#,0.00);\$#,0.00
		lineageTag: 5ed3900c-23f5-4adc-b7d2-11fe1fa620d4

		annotation PBI_FormatHint = {"currencyCulture":"en-US"}

	measure 'Variation #' = ```
			
			VAR _Delta = [Last Close Price Number] - [BeginingPeriodPrice]
			VAR _Currency = 
			    CALCULATE(
			        SELECTEDVALUE(dimCurrencySymbol[Currency Symbol]),
			        TREATAS(VALUES(dimMeta[Currency]), dimCurrencySymbol[Currency])
			    )
			VAR _Period = MAX(dimPeriod[Period])
			VAR _Arrow = 
			    IF(
			        _Delta > 0,
			        UNICHAR(129033), 
			        UNICHAR(129035)
			    ) & " "
			RETURN
			    _Arrow & FORMAT(_Delta, "0.00") & _Currency & " : " & _Period
			
			```
		lineageTag: e4834ebc-bf0c-45ce-8894-a228b4c78c8b

	measure 'Exponential Moving Average' = ```
			
			VAR _Period = SELECTEDVALUE(_tParameter[NbOfDays], 10)  -- Default period of 10 if not selected
			VAR _K = 2 / (_Period + 1)  -- Smoothing factor
			VAR _MaxDate = MAX(factStocks[Date])  -- Latest date in the current context
			VAR _DatesInPeriod = DATESINPERIOD(factStocks[Date], _MaxDate, -_Period, DAY)
			
			-- Step 1: Calculate Initial EMA as SMA of the first period
			VAR _InitialEMA = 
			    CALCULATE(
			        AVERAGE(factStocks[Close]),
			        _DatesInPeriod
			    )
			
			-- Step 2: Build Weighted Sum and Total Weight
			VAR _WeightedTable =
			    ADDCOLUMNS(
			        _DatesInPeriod,
			        "Close", CALCULATE(SUM(factStocks[Close])),
			        "Weight", _K * POWER(1 - _K, DATEDIFF(factStocks[Date], _MaxDate, DAY))
			    )
			
			VAR _WeightedSum = SUMX(_WeightedTable, [Close] * [Weight])
			VAR _TotalWeight = SUMX(_WeightedTable, [Weight])
			
			-- Step 3: Calculate EMA
			VAR _EMA = DIVIDE(_WeightedSum, _TotalWeight)
			
			RETURN
			    IF(ISBLANK(_InitialEMA), BLANK(), _EMA)
			```
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: 308ea926-0875-49ed-8c66-d80d7c092ca4

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure 'Lower Band' = ```
			
			VAR _Period = SELECTEDVALUE(_tParameter[NbOfDays])
			VAR _LastDate = LASTDATE(factStocks[Date])
			VAR _DatesInPeriod = DATESINPERIOD(factStocks[Date], _LastDate, -_Period, DAY)
			VAR _SMA = '_Measures'[Moving Average]
			VAR _StdDev = 
			    STDEVX.P(
			        _DatesInPeriod,
			        CALCULATE(SUM(factStocks[Close]))
			    )
			
			RETURN
			    _SMA - (2 * _StdDev)
			
			```
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: 3c4acb54-69e9-453f-88e7-362ae243bfee

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure 'Upper Band' = ```
			
			VAR _Period = SELECTEDVALUE(_tParameter[NbOfDays])
			VAR _LastDate = LASTDATE(factStocks[Date])
			VAR _DatesInPeriod = DATESINPERIOD(factStocks[Date], _LastDate, -_Period, DAY)
			VAR _SMA = '_Measures'[Moving Average]
			VAR _StdDev = 
			    STDEVX.P(
			        _DatesInPeriod,
			        CALCULATE(SUM(factStocks[Close]))
			    )
			
			RETURN
			    _SMA + (2 * _StdDev)
			
			```
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: d2cdbe67-48d6-4277-825c-784819eae0a8

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure 'Total Close Price' = SUM(factStocks[Close])
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: 2868d987-66c9-4584-a7d7-e74abe659ba5

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure Slope =
			
			VAR Known =
			    FILTER(
			        SELECTCOLUMNS(
			            ALLSELECTED('dimCalendar'[Date]),
			            "Known[X]", 'dimCalendar'[Date],
			            "Known[Y]", [Total Close Price]
			        ),
			        AND(
			            NOT(ISBLANK(Known[X])),
			            NOT(ISBLANK(Known[Y]))
			        )
			    )
			VAR Count_Items =
			    COUNTROWS(Known)
			VAR Sum_X =
			    SUMX(Known, Known[X])
			VAR Sum_X2 =
			    SUMX(Known, Known[X] ^ 2)
			VAR Sum_Y =
			    SUMX(Known, Known[Y])
			VAR Sum_XY =
			    SUMX(Known, Known[X] * Known[Y])
			VAR Average_X =
			    AVERAGEX(Known, Known[X])
			VAR Average_Y =
			    AVERAGEX(Known, Known[Y])
			RETURN
			    DIVIDE(
			        Count_Items * Sum_XY - Sum_X * Sum_Y,
			        Count_Items * Sum_X2 - Sum_X ^ 2
			    )
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: 29b3d254-33c0-472b-8c00-9ab2da45e03a

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure 'Last Close Price Blank' = CALCULATE(LASTNONBLANKVALUE(factStocks[Date],[Total Close Price]),ALLSELECTED(factStocks[Date]))
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: e798791b-a302-41b5-ad35-cfd74ca7dfe5

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure 'First Close Price Blank' = CALCULATE(FIRSTNONBLANKVALUE(factStocks[Date],[Total Close Price]),ALLSELECTED(factStocks[Date]))
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: 71fd74e5-3a02-4ea1-902f-f5f8b8670349

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure 'Up line' = IF([Last Close Price Blank]>[First Close Price Blank], [Total Close Price], BLANK())
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: f29e95ca-041a-4f4e-9b54-1041659118d9

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure 'Down line' = IF([Last Close Price Blank]<[First Close Price Blank], [Total Close Price], BLANK())
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: 42c8d276-e9cb-4859-8dc1-23cab7eba472

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure 'SVG_Sparkline with Intersect' = ```
			
			VAR topLineColour = "blue"
			VAR bottomLineColour = "magenta"
			
			// Get the selected period's StartDate and EndDate from dimPeriod
			VAR _SelectedPeriodStart = SELECTEDVALUE(dimPeriod[StartDate])
			VAR _SelectedPeriodEnd = SELECTEDVALUE(dimPeriod[EndDate])
			
			// Calculate the X-axis range based on the selected period (dimPeriod)
			VAR XMinDate = _SelectedPeriodStart
			VAR XMaxDate = _SelectedPeriodEnd
			
			// Calculate the minimum and maximum Y values within the selected date range (factStocks[Date] within the period)
			VAR YMinValue = MINX(
			    FILTER(factStocks, factStocks[Date] >= XMinDate && factStocks[Date] <= XMaxDate),
			    CALCULATE([sumClose])
			)
			VAR YMaxValue = MAXX(
			    FILTER(factStocks, factStocks[Date] >= XMinDate && factStocks[Date] <= XMaxDate),
			    CALCULATE([sumClose])
			)
			
			// Build a table of X & Y coordinates based on the selected period, scaled to fit 50x150 viewbox
			VAR SparklineTable = ADDCOLUMNS(
			    SUMMARIZE(
			        FILTER(factStocks, factStocks[Date] >= XMinDate && factStocks[Date] <= XMaxDate),
			        factStocks[Date]
			    ),
			    "X", INT(150 * DIVIDE(factStocks[Date] - XMinDate, XMaxDate - XMinDate)),  // Scale X based on the selected period
			    "Y", INT(50 * DIVIDE([sumClose] - YMinValue, YMaxValue - YMinValue))  // Scale Y based on the selected period
			)
			
			// Concatenate X & Y coordinates into a polyline for the sparkline
			VAR Lines = CONCATENATEX(SparklineTable, [X] & "," & 50 - [Y], " ", factStocks[Date])
			
			// Calculate the intersection line position based on the selected period's data
			VAR lineIntersection = AVERAGEX(
			    FILTER(factStocks, factStocks[Date] >= XMinDate && factStocks[Date] <= XMaxDate),
			    CALCULATE([sumClose])
			)
			VAR intersectScaled = INT(50 * DIVIDE(lineIntersection - YMinValue, YMaxValue - YMinValue))
			
			// SVG Definitions for styling and markers
			VAR Defs = 
			"<defs>
			    <clipPath id='cut-bottom'>
			      <rect x='0' y='0' width='150' height='" & intersectScaled & "' />
			    </clipPath>
			
			    <marker id='circle' markerWidth='4' markerHeight='4' refX='2' refY='2' >
			      <circle cx='2' cy='2' r='1' fill='steelblue' />
			    </marker>
			
			    <marker id='circleLarge' markerWidth='4' markerHeight='4' refX='2' refY='2' >
			      <circle cx='2' cy='2' r='1.25' fill='red' stroke='black' />
			    </marker>
			
			    <marker id='arrow' markerWidth='3' markerHeight='3' refX='2' refY='2' orient='auto' >
			      <path d='M 0 0 L 10 5 L 0 10 z' fill='black' />
			    </marker>
			</defs>"
			
			// Final SVG construction
			VAR SVGImageURL = 
			    "data:image/svg+xml;utf8," & 
			    "<svg xmlns='http://www.w3.org/2000/svg' x='0px' y='0px' viewBox='-5 -5 160 60' >" & Defs &
			    "<polyline fill='none' stroke='" & bottomLineColour & "' stroke-width='3' points='" & Lines & "' stroke-linecap='round' stroke-linejoin='round' marker-start='url(#circle)' marker-mid='url(#circle)' marker-end='url(#circleLarge)' />" & 
			    "<polyline fill='none' stroke='" & topLineColour & "' stroke-width='3' points='" & Lines & "' stroke-linecap='round' stroke-linejoin='round' clip-path='url(#cut-bottom)' marker-start='url(#circle)' marker-mid='url(#circle)' marker-end='url(#circleLarge)' />" & 
			    "<line x1='0' y1='" & intersectScaled & "' x2='150' y2='" & intersectScaled & "' stroke ='grey' stroke-width ='2' stroke-dasharray='5,5' />" &
			    "</svg>"
			
			RETURN SVGImageURL
			
			```
		lineageTag: a7da3cd0-d12d-417a-abf3-e067d37b6643
		dataCategory: ImageUrl

	measure sumClose = ```
			
			VAR _Period = SELECTEDVALUE(_tParameter[NbOfDays])
			VAR _LastDate = LASTDATE(factStocks[Date])
			VAR _DatesInPeriod = DATESINPERIOD(factStocks[Date], _LastDate, -_Period, DAY)
			VAR _SelectedPeriodStart = SELECTEDVALUE(dimPeriod[StartDate])
			VAR _SelectedPeriodEnd = SELECTEDVALUE(dimPeriod[EndDate])
			RETURN
			    CALCULATE(
			        SUM(factStocks[Close]),
			        _DatesInPeriod,
			        FILTER(
			            factStocks,
			            factStocks[Date] >= _SelectedPeriodStart &&
			            factStocks[Date] <= _SelectedPeriodEnd
			        ),
			        ALLEXCEPT(dimLogo, dimLogo[Company])  // Ensures calculation happens per company
			    )
			
			```
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: 3830dde8-d634-4d36-96cf-aaea1bd2bfc6

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure Slicer_SumOfClose = ```
			
			VAR _Period = SELECTEDVALUE(_tParameter[NbOfDays])
			VAR _LastDate = LASTDATE(dimSlicer[Date])
			VAR _DatesInPeriod = DATESINPERIOD(dimSlicer[Date], _LastDate, -_Period, DAY)
			VAR _SelectedPeriodStart = SELECTEDVALUE(dimPeriod[StartDate])
			VAR _SelectedPeriodEnd = SELECTEDVALUE(dimPeriod[EndDate])
			RETURN
			    CALCULATE(
			        SUM(dimSlicer[Close]),
			        _DatesInPeriod,
			        FILTER(
			            dimSlicer,
			            dimSlicer[Date] >= _SelectedPeriodStart &&
			            dimSlicer[Date] <= _SelectedPeriodEnd
			        ),
			        ALLEXCEPT(dimSlicer, dimSlicer[Company])  // Ensures calculation happens per company
			    )
			
			```
		formatString: "CHF"\ #,0.00;"CHF"-#,0.00;"CHF"\ #,0.00
		lineageTag: 5239f793-9bd8-48a9-a93c-d862254d7ab9

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure Slicer_SVG_Sparkline_with_Intersect = ```
			
			VAR topLineColour = "blue"
			VAR bottomLineColour = "magenta"
			
			// Get the selected period's StartDate and EndDate from dimPeriod
			VAR _SelectedPeriodStart = SELECTEDVALUE(dimPeriod[StartDate])
			VAR _SelectedPeriodEnd = SELECTEDVALUE(dimPeriod[EndDate])
			
			// Calculate the X-axis range based on the selected period (dimPeriod)
			VAR XMinDate = _SelectedPeriodStart
			VAR XMaxDate = _SelectedPeriodEnd
			
			// Calculate the minimum and maximum Y values within the selected date range (dimSlicer[Date] within the period)
			// No filter for dimSlicer[Company], so it applies to all companies
			VAR YMinValue = MINX(
			    FILTER(dimSlicer, 
			        dimSlicer[Date] >= XMinDate && 
			        dimSlicer[Date] <= XMaxDate),  // Consider all companies
			    CALCULATE([Slicer_SumOfClose])
			)
			
			VAR YMaxValue = MAXX(
			    FILTER(dimSlicer, 
			        dimSlicer[Date] >= XMinDate && 
			        dimSlicer[Date] <= XMaxDate),  // Consider all companies
			    CALCULATE([Slicer_SumOfClose])
			)
			
			// Build a table of X & Y coordinates based on the selected period, scaled to fit 50x150 viewbox, and consider all companies
			VAR SparklineTable = ADDCOLUMNS(
			    SUMMARIZE(
			        FILTER(dimSlicer, 
			            dimSlicer[Date] >= XMinDate && 
			            dimSlicer[Date] <= XMaxDate),  // Consider all companies
			        dimSlicer[Date], dimSlicer[Symbol]  // Include Symbol for each company
			    ),
			    "X", INT(150 * DIVIDE(dimSlicer[Date] - XMinDate, XMaxDate - XMinDate)),  // Scale X based on the selected period
			    "Y", INT(50 * DIVIDE([Slicer_SumOfClose] - YMinValue, YMaxValue - YMinValue))  // Scale Y based on the selected period
			)
			
			// Concatenate X & Y coordinates into a polyline for the sparkline
			VAR Lines = CONCATENATEX(SparklineTable, [X] & "," & (50 - [Y]), " ", dimSlicer[Date])
			
			// Calculate the intersection line position based on the selected period's data and for all companies
			VAR lineIntersection = AVERAGEX(
			    FILTER(dimSlicer, 
			        dimSlicer[Date] >= XMinDate && 
			        dimSlicer[Date] <= XMaxDate),  // Consider all companies
			    CALCULATE([Slicer_SumOfClose])
			)
			VAR intersectScaled = INT(50 * DIVIDE(lineIntersection - YMinValue, YMaxValue - YMinValue))
			
			// SVG Definitions for styling and markers
			VAR Defs = 
			"<defs>
			    <clipPath id='cut-bottom'>
			      <rect x='0' y='0' width='150' height='" & intersectScaled & "' />
			    </clipPath>
			
			    <marker id='circle' markerWidth='4' markerHeight='4' refX='2' refY='2' >
			      <circle cx='2' cy='2' r='1' fill='steelblue' />
			    </marker>
			
			    <marker id='circleLarge' markerWidth='4' markerHeight='4' refX='2' refY='2' >
			      <circle cx='2' cy='2' r='1.25' fill='red' stroke='black' />
			    </marker>
			
			    <marker id='arrow' markerWidth='3' markerHeight='3' refX='2' refY='2' orient='auto' >
			      <path d='M 0 0 L 10 5 L 0 10 z' fill='black' />
			    </marker>
			</defs>"
			
			// Final SVG construction
			VAR SVGImageURL = 
			    "data:image/svg+xml;utf8," & 
			    "<svg xmlns='http://www.w3.org/2000/svg' x='0px' y='0px' viewBox='-5 -5 160 60' >" & Defs &
			    "<polyline fill='none' stroke='" & bottomLineColour & "' stroke-width='3' points='" & Lines & "' stroke-linecap='round' stroke-linejoin='round' marker-start='url(#circle)' marker-mid='url(#circle)' marker-end='url(#circleLarge)' />" & 
			    "<polyline fill='none' stroke='" & topLineColour & "' stroke-width='3' points='" & Lines & "' stroke-linecap='round' stroke-linejoin='round' clip-path='url(#cut-bottom)' marker-start='url(#circle)' marker-mid='url(#circle)' marker-end='url(#circleLarge)' />" & 
			    "<line x1='0' y1='" & intersectScaled & "' x2='150' y2='" & intersectScaled & "' stroke ='grey' stroke-width ='2' stroke-dasharray='5,5' />" & 
			    "</svg>"
			
			RETURN SVGImageURL
			
			```
		lineageTag: 13f39096-3e7a-4e25-8d4d-bcc473520bb9
		dataCategory: ImageUrl

	measure Delta = [Last Close Price Number] - [BeginingPeriodPrice]
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: d35dbfa1-7998-4249-bbf7-f1e4eeee22d2

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure SVG = ```
			
			    VAR LineColourPositive = "#00A651"  // Green line for positive Delta
			    VAR LineColourNegative = "#FF0000"  // Red line for negative Delta
			    VAR PointColour = "white"            // White points on the line
			
			    // Gradient definitions for positive and negative Delta
			    VAR DefsPositive = "<defs>
			        <linearGradient id='grad' x1='0' y1='25' x2='0' y2='50' gradientUnits='userSpaceOnUse'>
			            <stop stop-color='#00A651' offset='0' />
			            <stop stop-color='#00A651' offset='0.3' />
			            <stop stop-color='white' offset='1' />
			        </linearGradient>
			    </defs>"
			    
			    VAR DefsNegative = "<defs>
			        <linearGradient id='grad' x1='0' y1='25' x2='0' y2='50' gradientUnits='userSpaceOnUse'>
			            <stop stop-color='#FF0000' offset='0' />
			            <stop stop-color='#FF0000' offset='0.3' />
			            <stop stop-color='white' offset='1' />
			        </linearGradient>
			    </defs>"
			    
			    // Date range for the sparkline (X axis) from the same dataset as the original logic
			    VAR XMinDate = SELECTEDVALUE(dimPeriod[StartDate])  // StartDate from dimPeriod table
			    VAR XMaxDate = SELECTEDVALUE(dimPeriod[EndDate])    // EndDate from dimPeriod table
			    
			    // Calculate overall min and max stock closing values for the selected date range
			    VAR YMinValue = MINX(
			        FILTER(factStocks, factStocks[Date] >= XMinDate && factStocks[Date] <= XMaxDate),
			        CALCULATE([sumClose])
			    )
			    VAR YMaxValue = MAXX(
			        FILTER(factStocks, factStocks[Date] >= XMinDate && factStocks[Date] <= XMaxDate),
			        CALCULATE([sumClose])
			    )
			    
			    // Build table of X & Y coordinates based on the same date range, scaled to the 50 x 150 viewbox
			    VAR SparklineTable = ADDCOLUMNS(
			        SUMMARIZE(
			            FILTER(factStocks, factStocks[Date] >= XMinDate && factStocks[Date] <= XMaxDate),
			            factStocks[Date]
			        ),
			        "X", INT(150 * DIVIDE(factStocks[Date] - XMinDate, XMaxDate - XMinDate)),
			        "Y", INT(50 * DIVIDE([sumClose] - YMinValue, YMaxValue - YMinValue))
			    )
			    
			    // Concatenate X & Y coordinates to form the sparkline line path
			    VAR Lines = CONCATENATEX(SparklineTable, [X] & "," & 50 - [Y], " ", factStocks[Date])
			    
			    // Last data points for highlighting the final point on the sparkline
			    VAR LastSparkYValue = MAXX(FILTER(SparklineTable, factStocks[Date] = XMaxDate), [Y])
			    VAR LastSparkXValue = MAXX(FILTER(SparklineTable, factStocks[Date] = XMaxDate), [X])
			    
			    // Determine whether the Delta is positive or negative and use the corresponding gradient and line color
			    VAR Gradient = IF([Delta] > 0, DefsPositive, DefsNegative)
			    VAR LineColour = IF([Delta] > 0, LineColourPositive, LineColourNegative)
			    
			    // Scale the Moving Average value to fit the 50 x 150 viewbox
			    VAR ReferenceLineScaled = INT(50 * DIVIDE([Moving Average] - YMinValue, YMaxValue - YMinValue))
			    
			    // Build the SVG image
			    VAR SVGImageURL = 
			        "data:image/svg+xml;utf8," & 
			        "<svg xmlns='http://www.w3.org/2000/svg' x='0px' y='0px' viewBox='-7 -7 164 64'>" & 
			        Gradient &  // Use the correct gradient definition (green or red)
			        // Opaque area filled with gradient
			        "<polyline fill='url(#grad)' fill-opacity='0.3' stroke='transparent' stroke-width='0' points='0,50 " & Lines & " 150,50 Z' />" & 
			        // Line with the defined color and stroke width
			        "<polyline fill='transparent' stroke='" & LineColour & "' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' points='" & Lines & "' />" & 
			        // Last point with the circle to highlight it
			        "<circle cx='" & LastSparkXValue & "' cy='" & 50 - LastSparkYValue & "' r='4' stroke='" & LineColour & "' stroke-width='3' fill='" & PointColour & "' />" & 
			        // Add the reference line (moving average line) at the calculated position
			        "<line x1='0' y1='" & ReferenceLineScaled & "' x2='150' y2='" & ReferenceLineScaled & "' stroke='grey' stroke-width='2' stroke-dasharray='5,5' />" & 
			        "</svg>"
			    
			    RETURN 
			        SVGImageURL
			
			```
		lineageTag: 018f5a74-c661-4f24-b27e-9ae0e2f700fe
		dataCategory: ImageUrl

	measure Slicer_SVG = ```
			
			    VAR LineColourPositive = "#00A651"  // Green line for positive Slicer_Delta
			    VAR LineColourNegative = "#FF0000"  // Red line for negative Slicer_Delta
			    VAR PointColour = "white"           // White points on the line
			
			    // Gradient definitions for positive and negative Slicer_Delta
			    VAR DefsPositive = "<defs>
			        <linearGradient id='grad' x1='0' y1='22.5' x2='0' y2='45' gradientUnits='userSpaceOnUse'>
			            <stop stop-color='#00A651' offset='0' />
			            <stop stop-color='#00A651' offset='0.3' />
			            <stop stop-color='white' offset='1' />
			        </linearGradient>
			    </defs>"
			
			    VAR DefsNegative = "<defs>
			        <linearGradient id='grad' x1='0' y1='22.5' x2='0' y2='45' gradientUnits='userSpaceOnUse'>
			            <stop stop-color='#FF0000' offset='0' />
			            <stop stop-color='#FF0000' offset='0.3' />
			            <stop stop-color='white' offset='1' />
			        </linearGradient>
			    </defs>"
			
			    // Date range for the sparkline (X axis) from the same dataset as the original logic
			    VAR XMinDate = SELECTEDVALUE(dimPeriod[StartDate])  // StartDate from dimPeriod table
			    VAR XMaxDate = CALCULATE(
			        MAX(dimSlicer[Date]), 
			        dimSlicer[Date] <= SELECTEDVALUE(dimPeriod[EndDate])
			    )  // Find the last date in dimSlicer that is <= EndDate from dimPeriod
			
			    // Calculate overall min and max stock closing values for the selected date range
			    VAR YMinValue = MINX(
			        FILTER(dimSlicer, dimSlicer[Date] >= XMinDate && dimSlicer[Date] <= XMaxDate),
			        CALCULATE([Slicer_SumOfClose])
			    )
			    VAR YMaxValue = MAXX(
			        FILTER(dimSlicer, dimSlicer[Date] >= XMinDate && dimSlicer[Date] <= XMaxDate),
			        CALCULATE([Slicer_SumOfClose])
			    )
			
			    // Build table of X & Y coordinates based on the same date range, scaled to the 60x30 viewbox
			    VAR SparklineTable = ADDCOLUMNS(
			        SUMMARIZE(
			            FILTER(dimSlicer, dimSlicer[Date] >= XMinDate && dimSlicer[Date] <= XMaxDate),
			            dimSlicer[Date]
			        ),
			        "X", INT(60 * DIVIDE(dimSlicer[Date] - XMinDate, XMaxDate - XMinDate)),
			        "Y", INT(30 * DIVIDE([Slicer_SumOfClose] - YMinValue, YMaxValue - YMinValue))
			    )
			
			    // Concatenate X & Y coordinates to form the sparkline line path
			    VAR Lines = CONCATENATEX(SparklineTable, [X] & "," & 30 - [Y], " ", dimSlicer[Date])
			
			    // Last data points for highlighting the final point on the sparkline
			    VAR LastSparkYValue = MAXX(FILTER(SparklineTable, dimSlicer[Date] = XMaxDate), [Y])
			    VAR LastSparkXValue = MAXX(FILTER(SparklineTable, dimSlicer[Date] = XMaxDate), [X])
			
			    // Determine whether the Slicer_Delta is positive or negative and use the corresponding gradient and line color
			    VAR Gradient = IF([Slicer_Delta] > 0, DefsPositive, DefsNegative)
			    VAR LineColour = IF([Slicer_Delta] > 0, LineColourPositive, LineColourNegative)
			
			    // Scale the Moving Average value to fit the 30x60 viewbox
			    VAR ReferenceLineScaled = INT(30 * DIVIDE([Slicer_Moving_Average] - YMinValue, YMaxValue - YMinValue))
			
			    // Build the SVG image
			    VAR SVGImageURL = 
			        "data:image/svg+xml;utf8," & 
			        "<svg xmlns='http://www.w3.org/2000/svg' x='0px' y='0px' viewBox='-4 -4 67 37'>" & 
			        Gradient &  // Use the correct gradient definition (green or red)
			        // Opaque area filled with gradient
			        "<polyline fill='url(#grad)' fill-opacity='0.3' stroke='transparent' stroke-width='0' points='0,30 " & Lines & " 60,30 Z' />" & 
			        // Line with the defined color and stroke width
			        "<polyline fill='transparent' stroke='" & LineColour & "' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' points='" & Lines & "' />" & 
			        // Last point with the circle to highlight it
			        "<circle cx='" & LastSparkXValue & "' cy='" & 30 - LastSparkYValue & "' r='2.5' stroke='" & LineColour & "' stroke-width='2' fill='" & PointColour & "' />" & 
			        // Add the reference line (moving average line) at the calculated position
			        "<line x1='0' y1='" & ReferenceLineScaled & "' x2='60' y2='" & ReferenceLineScaled & "' stroke='grey' stroke-width='1.5' stroke-dasharray='4,4' />" & 
			        "</svg>"
			
			    RETURN 
			        SVGImageURL
			
			```
		lineageTag: 1ae7e3d7-f205-4625-abce-201b4d97fa59
		dataCategory: ImageUrl

	measure Slicer_Last_Close_Price_Number = ```
			
			VAR _EndDate = CALCULATE(MAX(dimPeriod[EndDate]), ALLSELECTED(dimPeriod))
			VAR _LastDate = 
			    CALCULATE(
			        MAX(dimSlicer[Date]),  // Find the maximum date from dimSlicer that is less than or equal to _EndDate
			        FILTER(dimSlicer, dimSlicer[Date] <= _EndDate)
			    )
			RETURN
			    CALCULATE(
			        AVERAGE(dimSlicer[Close]),  // Calculate the average close price for that date
			        FILTER(dimSlicer, dimSlicer[Date] = _LastDate)
			    )
			
			```
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: cad8ced7-b998-44d4-9765-328253638b7b

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure Slicer_BeginningPeriodPrice = ```
			
			VAR _Price = 
			    CALCULATE(
			        MAX(dimSlicer[Close]), 
			        dimSlicer[Date] = MAX(dimPeriod[StartDate])
			    )
			VAR _AdjustedPrice = 
			    CALCULATE(
			        MAX(dimSlicer[Close]), 
			        dimSlicer[Date] = MAX(dimPeriod[StartDate]) + 1
			    )
			RETURN
			IF( 
			    _Price = BLANK(), 
			    _AdjustedPrice, 
			    _Price 
			)
			```
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: 0dab72eb-b89e-43aa-aad4-b6878f1a3322

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure Slicer_Delta = [Slicer_Last_Close_Price_Number] - [Slicer_BeginningPeriodPrice]
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: 5a0063e0-64e0-4b25-9788-569e26d8f866

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure Slicer_Moving_Average = ```
			
			VAR _Period = SELECTEDVALUE(_tParameter[NbOfDays], 10)  -- Default to 7 days if no value selected
			VAR _MaxDate = LASTDATE(dimSlicer[Date])  -- Get the latest date in the current context
			VAR _StartDate = _MaxDate - _Period + 1  -- Calculate the start date of the moving window
			
			VAR _Numerator = CALCULATE(
			    SUM(dimSlicer[Close]), 
			    dimSlicer[Date] >= _StartDate && dimSlicer[Date] <= _MaxDate  -- Filter for the current period
			)
			
			VAR _Denominator = CALCULATE(
			    COUNT(dimSlicer[Date]), 
			    dimSlicer[Date] >= _StartDate && dimSlicer[Date] <= _MaxDate  -- Filter for the current period
			)
			
			RETURN 
			IF(_Denominator > 0, DIVIDE(_Numerator, _Denominator), BLANK())  -- Return the average or blank if no data
			
			```
		formatString: "CHF"\ #,0.###############;"CHF"-#,0.###############;"CHF"\ #,0.###############
		lineageTag: 7c941390-60b8-4a0a-97b4-cceccd2ce49d

		annotation PBI_FormatHint = {"currencyCulture":"en-CH"}

	measure slicerSumOfClose = ```
			
			VAR _Period = SELECTEDVALUE(_tParameter[NbOfDays])  // Number of days for the period
			VAR _EndDate = CALCULATE(MAX(dimPeriod[EndDate]), ALLSELECTED(dimPeriod))  // Get the EndDate from the period
			VAR _LastDate = 
			    CALCULATE(
			        LASTDATE(dimSlicer[Date]),  // Find the maximum date in dimSlicer that is less than or equal to _EndDate
			        dimSlicer[Date] <= _EndDate
			    )
			VAR _DatesInPeriod = DATESINPERIOD(dimSlicer[Date], _LastDate, -_Period, DAY)  // Get the period range based on _LastDate
			VAR _SelectedPeriodStart = SELECTEDVALUE(dimPeriod[StartDate])  // Get the StartDate from the selected period
			VAR _SelectedPeriodEnd = SELECTEDVALUE(dimPeriod[EndDate])  // Get the EndDate from the selected period
			RETURN
			    CALCULATE(
			        SUM(dimSlicer[Close]),  // Sum the Close values
			        _DatesInPeriod,  // Filter by the period range
			        FILTER(
			            dimSlicer,
			            dimSlicer[Date] >= _SelectedPeriodStart &&  // Filter by the selected start date
			            dimSlicer[Date] <= _SelectedPeriodEnd  // Filter by the selected end date
			        ),
			        ALLEXCEPT(dimSlicer, dimSlicer[Company])  // Ensure calculation is done per company
			    )
			
			```
		lineageTag: 9d9f9926-df3a-419b-8da0-8f4fa5148b3b

		formatStringDefinition = ```
				VAR SelectedCurrency = 
				    CALCULATE(
				        SELECTEDVALUE(dimCurrencySymbol[Currency Symbol]),
				        TREATAS(VALUES(dimMeta[Currency]), dimCurrencySymbol[Currency])
				    )
				RETURN
				    "#,0.00#" & " " & SelectedCurrency
				
				
				
				
				--"\$#,0.###############;(\$#,0.###############);\$#,0.###############"
				```

	measure _testx2 = ```
			
			VAR SelectedCurrency = 
			    CALCULATE(
			        SELECTEDVALUE(dimCurrencySymbol[Currency Symbol]),
			        TREATAS(VALUES(dimMeta[Currency]), dimCurrencySymbol[Currency])
			    )
			VAR Price = AVERAGE('factStocks'[Low])
			RETURN
			    FORMAT(Price, "#,0.00#") & " " & SelectedCurrency
			
			```
		lineageTag: dfd3a095-0cd6-47dc-8b0c-5900fdde80ac

	measure _tesx3 = ```
			[At Close] & UNICHAR(10) & [At Close]
			
			```
		lineageTag: 0839c7e8-ea3a-4b92-a34c-e07581719c75

	measure _test999 = ```
			
			    VAR LineColourPositive = "#00A651"  // Verde pentru linie pozitivÄƒ
			    VAR LineColourNegative = "#FF0000"  // RoÈ™u pentru linie negativÄƒ
			    VAR PointColour = "white"           // Alb pentru puncte
			
			    // DefiniÈ›ii de gradient pentru zona umplutÄƒ cu efect fad
			    VAR DefsPositive = "<defs>
			        <linearGradient id='grad' x1='0' y1='22.5' x2='0' y2='250' gradientUnits='userSpaceOnUse'>
			            <stop stop-color='#00A651' offset='0' />
			            <stop stop-color='#00A651' offset='0.5' />
			            <stop stop-color='#00A651' offset='1' />
			        </linearGradient>
			    </defs>"
			
			    VAR DefsNegative = "<defs>
			        <linearGradient id='grad' x1='0' y1='22.5' x2='0' y2='250' gradientUnits='userSpaceOnUse'>
			            <stop stop-color='#FF0000' offset='0' />
			            <stop stop-color='#FF0000' offset='0.5' />
			            <stop stop-color='#FF0000' offset='1' />
			        </linearGradient>
			    </defs>"
			
			    VAR XMinDate = SELECTEDVALUE(dimPeriod[StartDate])
			    VAR XMaxDate = SELECTEDVALUE(dimPeriod[EndDate])
			
			    VAR YMinValue = MINX(
			        FILTER(dimSlicer, dimSlicer[Date] >= XMinDate && dimSlicer[Date] <= XMaxDate),
			        CALCULATE([Slicer_SumOfClose])
			    )
			    VAR YMaxValue = MAXX(
			        FILTER(dimSlicer, dimSlicer[Date] >= XMinDate && dimSlicer[Date] <= XMaxDate),
			        CALCULATE([Slicer_SumOfClose])
			    )
			
			    // Dimensiuni mai mari pentru grafic
			    VAR SparklineTable = ADDCOLUMNS(
			        SUMMARIZE(
			            FILTER(dimSlicer, dimSlicer[Date] >= XMinDate && dimSlicer[Date] <= XMaxDate),
			            dimSlicer[Date]
			        ),
			        "X", INT(400 * DIVIDE(dimSlicer[Date] - XMinDate, XMaxDate - XMinDate)), 
			        "Y", INT(250 * DIVIDE([Slicer_SumOfClose] - YMinValue, YMaxValue - YMinValue))
			    )
			
			    VAR Lines = CONCATENATEX(SparklineTable, [X] & "," & 250 - [Y], " ", dimSlicer[Date])
			
			    VAR LastSparkYValue = MAXX(FILTER(SparklineTable, dimSlicer[Date] = XMaxDate), [Y])
			    VAR LastSparkXValue = MAXX(FILTER(SparklineTable, dimSlicer[Date] = XMaxDate), [X])
			
			    VAR Gradient = IF([Slicer_Delta] > 0, DefsPositive, DefsNegative)
			    VAR LineColour = IF([Slicer_Delta] > 0, LineColourPositive, LineColourNegative)
			
			    VAR ReferenceLineScaled = INT(250 * DIVIDE([Slicer_Moving_Average] - YMinValue, YMaxValue - YMinValue))
			
			    VAR SVGImageURL = 
			        "data:image/svg+xml;utf8," & 
			        "<svg xmlns='http://www.w3.org/2000/svg' x='0px' y='0px' viewBox='-4 -4 404 254'>" & 
			        Gradient & 
			        // Zona de umplere cu gradient fad
			        "<polyline fill='url(#grad)' fill-opacity='0.2' stroke='transparent' stroke-width='0' points='0,250 " & Lines & " 400,250 Z' />" & 
			        // Linia principalÄƒ cu grosime mai mare pentru a o face mai vizibilÄƒ
			        "<polyline fill='transparent' stroke='" & LineColour & "' stroke-linecap='round' stroke-linejoin='round' stroke-width='6' points='" & Lines & "' />" & 
			        // Punctul final cu un cerc mai vizibil
			        "<circle cx='" & LastSparkXValue & "' cy='" & 250 - LastSparkYValue & "' r='5' stroke='" & LineColour & "' stroke-width='4' fill='" & PointColour & "' />" & 
			        // Linia de referinÈ›Äƒ a mediei mobile
			        "<line x1='0' y1='" & ReferenceLineScaled & "' x2='400' y2='" & ReferenceLineScaled & "' stroke='grey' stroke-width='3' stroke-dasharray='6,6' />" & 
			        "</svg>"
			
			    RETURN 
			        SVGImageURL
			
			```
		lineageTag: 45ec900d-4228-440f-b595-14d0a283a432
		dataCategory: ImageUrl

	measure _tex12321 = ```
			
			// Static line color - use %23 instead of # for Firefox compatibility (Measure Derived from Eldersveld Modified by Kolosko)
			VAR LineColour = "%23118DFF"
			VAR PointColour = "white"
			VAR Defs = "<defs>
			    <linearGradient id='grad' x1='0' y1='25' x2='0' y2='50' gradientUnits='userSpaceOnUse'>
			        <stop stop-color='#118DFF' offset='0' />
			        <stop stop-color='#118DFF' offset='0.3' />
			        <stop stop-color='white' offset='1' />
			    </linearGradient>
			</defs>"
			// "Date" field used in this example along the X axis
			VAR XMinDate = MIN(dimPeriod[StartDate])
			VAR XMaxDate = MAX(dimPeriod[EndDate])
			
			// Obtain overall min and overall max measure values when evaluated for each date
			VAR YMinValue = MINX(Values(dimSlicer[Date]),CALCULATE([slicerSumOfClose]))
			VAR YMaxValue = MAXX(Values(dimSlicer[Date]),CALCULATE([slicerSumOfClose]))
			
			// Build table of X & Y coordinates and fit to 50 x 150 viewbox
			VAR SparklineTable = ADDCOLUMNS(
			    SUMMARIZE('dimSlicer',dimSlicer[Date]),
			        "X",INT(150 * DIVIDE(dimSlicer[Date] - XMinDate, XMaxDate - XMinDate)),
			        "Y",INT(50 * DIVIDE([slicerSumOfClose] - YMinValue,YMaxValue - YMinValue)))
			
			// Concatenate X & Y coordinates to build the sparkline
			VAR Lines = CONCATENATEX(SparklineTable,[X] & "," & 50-[Y]," ", dimSlicer[Date])
			
			// Last data points on the line
			VAR LastSparkYValue = MAXX( FILTER(SparklineTable, dimSlicer[Date] = XMaxDate), [Y])
			VAR LastSparkXValue = MAXX( FILTER(SparklineTable, dimSlicer[Date] = XMaxDate), [X])
			
			// Add to SVG, and verify Data Category is set to Image URL for this measure
			VAR SVGImageURL = 
			    "data:image/svg+xml;utf8," & 
			    --- gradient---
			    "<svg xmlns='http://www.w3.org/2000/svg' x='0px' y='0px' viewBox='-7 -7 164 64'>" & Defs & 
			     "<polyline fill='url(#grad)' fill-opacity='0.3' stroke='transparent' 
			      stroke-width='0' points=' 0 50 " & Lines & 
			      " 150 150 Z '/>" &
			    --- Lines---
			    "<polyline 
			        fill='transparent' stroke='" & LineColour & "' 
			        stroke-linecap='round' stroke-linejoin='round' 
			        stroke-width='3' points=' " & Lines & 
			      " '/>" &
			    --- Last Point---
			        "<circle cx='"& LastSparkXValue & "' cy='" & 50 - LastSparkYValue & "' r='4' stroke='" & LineColour & "' stroke-width='3' fill='" & PointColour & "' />" &
			        "</svg>"
			RETURN SVGImageURL
			```
		lineageTag: cad17bec-c069-4c4e-956d-f01086684ece
		dataCategory: ImageUrl

	measure _text992121 = ```
			
			    VAR LineColourPositive = "#00A651"
			    VAR LineColourNegative = "#FF0000"
			    VAR PointColour = "white"
			
			    VAR DefsPositive = "<defs>
			        <linearGradient id='grad' x1='0' y1='50' x2='0' y2='100' gradientUnits='userSpaceOnUse'>
			            <stop stop-color='#00A651' offset='0' />
			            <stop stop-color='#00A651' offset='0.3' />
			            <stop stop-color='white' offset='1' />
			        </linearGradient>
			    </defs>"
			
			    VAR DefsNegative = "<defs>
			        <linearGradient id='grad' x1='0' y1='50' x2='0' y2='100' gradientUnits='userSpaceOnUse'>
			            <stop stop-color='#FF0000' offset='0' />
			            <stop stop-color='#FF0000' offset='0.3' />
			            <stop stop-color='white' offset='1' />
			        </linearGradient>
			    </defs>"
			
			    VAR XMinDate = SELECTEDVALUE(dimPeriod[StartDate])
			    VAR XMaxDate = SELECTEDVALUE(dimPeriod[EndDate])
			
			    VAR YMinValue = MINX(
			        FILTER(dimSlicer, dimSlicer[Date] >= XMinDate && dimSlicer[Date] <= XMaxDate),
			        CALCULATE([Slicer_SumOfClose])
			    )
			    VAR YMaxValue = MAXX(
			        FILTER(dimSlicer, dimSlicer[Date] >= XMinDate && dimSlicer[Date] <= XMaxDate),
			        CALCULATE([Slicer_SumOfClose])
			    )
			
			    VAR SparklineTable = ADDCOLUMNS(
			        SUMMARIZE(
			            FILTER(dimSlicer, dimSlicer[Date] >= XMinDate && dimSlicer[Date] <= XMaxDate),
			            dimSlicer[Date]
			        ),
			        "X", INT(180 * DIVIDE(dimSlicer[Date] - XMinDate, XMaxDate - XMinDate) + 10), // Scaled for larger graph
			        "Y", INT(90 * DIVIDE([Slicer_SumOfClose] - YMinValue, YMaxValue - YMinValue) + 5) // Scaled for larger graph
			    )
			
			    VAR Lines = CONCATENATEX(SparklineTable, [X] & "," & 100 - [Y], " ", dimSlicer[Date])
			
			    VAR LastSparkYValue = MAXX(FILTER(SparklineTable, dimSlicer[Date] = XMaxDate), [Y])
			    VAR LastSparkXValue = MAXX(FILTER(SparklineTable, dimSlicer[Date] = XMaxDate), [X])
			
			    VAR Gradient = IF([Slicer_Delta] > 0, DefsPositive, DefsNegative)
			    VAR LineColour = IF([Slicer_Delta] > 0, LineColourPositive, LineColourNegative)
			
			    VAR ReferenceLineScaled = INT(90 * DIVIDE([Slicer_Moving_Average] - YMinValue, YMaxValue - YMinValue) + 5)
			
			    VAR SVGImageURL =
			        "data:image/svg+xml;utf8," &
			        "<svg xmlns='http://www.w3.org/2000/svg' x='0px' y='0px' viewBox='-4 -4 208 108'>" &
			        Gradient &
			        "<polyline fill='url(#grad)' fill-opacity='0.3' stroke='transparent' stroke-width='0' points='10,95 " &
			            CONCATENATEX(SparklineTable, [X] & "," & 100 - [Y], " ", dimSlicer[Date]) &
			            " 190,95 Z' />" &
			        "<polyline fill='transparent' stroke='" & LineColour & "' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' points='" &
			            CONCATENATEX(SparklineTable, [X] & "," & 100 - [Y], " ", dimSlicer[Date]) &
			            "' />" &
			        "<circle cx='" & LastSparkXValue & "' cy='" & 100 - LastSparkYValue & "' r='3' stroke='" & LineColour & "' stroke-width='2' fill='" & PointColour & "' />" &
			        "<line x1='10' y1='" & ReferenceLineScaled & "' x2='190' y2='" & ReferenceLineScaled & "' stroke='grey' stroke-width='1.5' stroke-dasharray='4,4' />" &
			        "</svg>"
			
			RETURN 
			    SVGImageURL
			
			```
		lineageTag: 0a655a90-f36c-45c3-b097-a43b07838e4b
		dataCategory: ImageUrl

	measure _text99s = ```
			
			    VAR LineColourPositive = "#00A651"
			    VAR LineColourNegative = "#FF0000"
			    VAR PointColour = "white"
			
			    VAR DefsPositive = "<defs>
			        <linearGradient id='grad' x1='0' y1='100' x2='0' y2='200' gradientUnits='userSpaceOnUse'>
			            <stop stop-color='#00A651' offset='0' />
			            <stop stop-color='#00A651' offset='0.3' />
			            <stop stop-color='white' offset='1' />
			        </linearGradient>
			    </defs>"
			
			    VAR DefsNegative = "<defs>
			        <linearGradient id='grad' x1='0' y1='100' x2='0' y2='200' gradientUnits='userSpaceOnUse'>
			            <stop stop-color='#FF0000' offset='0' />
			            <stop stop-color='#FF0000' offset='0.3' />
			            <stop stop-color='white' offset='1' />
			        </linearGradient>
			    </defs>"
			
			    VAR XMinDate = SELECTEDVALUE(dimPeriod[StartDate])
			    VAR XMaxDate = SELECTEDVALUE(dimPeriod[EndDate])
			
			    VAR YMinValue = MINX(
			        FILTER(dimSlicer, dimSlicer[Date] >= XMinDate && dimSlicer[Date] <= XMaxDate),
			        CALCULATE([Slicer_SumOfClose])
			    )
			    VAR YMaxValue = MAXX(
			        FILTER(dimSlicer, dimSlicer[Date] >= XMinDate && dimSlicer[Date] <= XMaxDate),
			        CALCULATE([Slicer_SumOfClose])
			    )
			
			    VAR SparklineTable = ADDCOLUMNS(
			        SUMMARIZE(
			            FILTER(dimSlicer, dimSlicer[Date] >= XMinDate && dimSlicer[Date] <= XMaxDate),
			            dimSlicer[Date]
			        ),
			        "X", INT(380 * DIVIDE(dimSlicer[Date] - XMinDate, XMaxDate - XMinDate) + 10),
			        "Y", INT(180 * DIVIDE([Slicer_SumOfClose] - YMinValue, YMaxValue - YMinValue) + 10)
			    )
			
			    VAR Lines = CONCATENATEX(SparklineTable, [X] & "," & 200 - [Y], " ", dimSlicer[Date])
			
			    VAR LastSparkYValue = MAXX(FILTER(SparklineTable, dimSlicer[Date] = XMaxDate), [Y])
			    VAR LastSparkXValue = MAXX(FILTER(SparklineTable, dimSlicer[Date] = XMaxDate), [X])
			
			    VAR Gradient = IF([Slicer_Delta] > 0, DefsPositive, DefsNegative)
			    VAR LineColour = IF([Slicer_Delta] > 0, LineColourPositive, LineColourNegative)
			
			    VAR ReferenceLineScaled = INT(180 * DIVIDE([Slicer_Moving_Average] - YMinValue, YMaxValue - YMinValue) + 10)
			
			    VAR SVGImageURL =
			        "data:image/svg+xml;utf8," &
			        "<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 200' width='400' height='200' preserveAspectRatio='xMidYMid meet'>" &
			        Gradient &
			        "<rect x='0' y='0' width='400' height='200' fill='white' />" &  // Background
			        "<polyline fill='url(#grad)' fill-opacity='0.3' stroke='transparent' stroke-width='0' points='10,190 " &
			            CONCATENATEX(SparklineTable, [X] & "," & 200 - [Y], " ", dimSlicer[Date]) &
			            " 390,190 Z' />" &
			        "<polyline fill='transparent' stroke='" & LineColour & "' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' points='" &
			            CONCATENATEX(SparklineTable, [X] & "," & 200 - [Y], " ", dimSlicer[Date]) &
			            "' />" &
			        "<circle cx='" & LastSparkXValue & "' cy='" & 200 - LastSparkYValue & "' r='4' stroke='" & LineColour & "' stroke-width='2' fill='" & PointColour & "' />" &
			        "<line x1='10' y1='" & ReferenceLineScaled & "' x2='390' y2='" & ReferenceLineScaled & "' stroke='grey' stroke-width='2' stroke-dasharray='4,4' />" &
			        "</svg>"
			
			RETURN 
			    SVGImageURL
			
			```
		lineageTag: e0550893-0a66-4f02-b0e4-fc1a4140c0eb
		dataCategory: ImageUrl

	measure '_test 01' =
			
			VAR _Company = MAX(dimSlicer[Company])
			VAR _Symbol = MAX(dimSlicer[Symbol])
			VAR _Industry = MAX(dimSlicer[Industry])
			VAR _Sector = MAX(dimSlicer[Sector])
			VAR NewLine =
			"
			"
			RETURN
			_Company & NewLine & "ðŸ·ï¸:" & _Sector
		lineageTag: e103cd57-f1ba-45ba-a1bd-8dc54b7ccd50
		dataCategory: Uncategorized

	measure _abtest =
			
			VAR _Company = MAX(dimMeta[Company Name])
			VAR _Symbol = MAX(dimMeta[Symbol])
			VAR _MarketRef = MAX(dimMeta[Exchange Name])
			VAR _Currency = MAX(dimMeta[Currency])
			VAR NewLine =
			"
			"
			RETURN
			_Company & NewLine & "ðŸ·ï¸:" & _Symbol & " | " & "ðŸª™:" & _Currency & " | " & "ðŸ’°:" & _MarketRef
		lineageTag: ed25ac51-2d01-4b8b-9dfb-0aa5569ec480
		dataCategory: ImageUrl

	column _Blank
		formatString: 0
		lineageTag: a889a677-a184-452c-9ab3-1dbdcb601569
		summarizeBy: sum
		isNameInferred
		sourceColumn: [_Blank]

		annotation SummarizationSetBy = Automatic

	partition _Measures = calculated
		mode: import
		source = Row("_Blank", BLANK())

	annotation PBI_Id = d3fe511137dc4693a1ba9c24c6d6306b

	annotation 436ba87b-9c83-4389-a31b-ebd06a36be98 = {"Expression":""}

